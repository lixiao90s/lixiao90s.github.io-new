[ { "title": null, "url": "/posts/2024-03-11-welcome/", "categories": "", "tags": "", "date": "2025-03-12 12:04:54 +0800", "snippet": "关于我热衷于技术探索和工程实践的全栈开发者，专注于游戏开发与服务端架构。持续学习，乐于分享，用代码构建有趣的数字世界。技术栈游戏开发 Unity 客户端开发 游戏性能优化 游戏架构设计 Lua 脚本开发服务端开发 Java 企业级应用开发 Spring Framework 生态系统 高性能数据库设计 (MySQL, Redis) 分布式系统架构 akka核心技能 编程语言：...", "content": "关于我热衷于技术探索和工程实践的全栈开发者，专注于游戏开发与服务端架构。持续学习，乐于分享，用代码构建有趣的数字世界。技术栈游戏开发 Unity 客户端开发 游戏性能优化 游戏架构设计 Lua 脚本开发服务端开发 Java 企业级应用开发 Spring Framework 生态系统 高性能数据库设计 (MySQL, Redis) 分布式系统架构 akka核心技能 编程语言：Java, C#, Lua 数据库：MySQL, Redis 开发工具：Git unity 逆向博客内容这里记录了我在技术探索过程中的： 学习笔记与心得 项目实践经验 技术难点解决方案 系统架构设计思考 性能优化案例分析更新计划持续分享以下领域的内容： Unity 游戏开发实践 java 服务器相关技术 数据库 分布式系统设计 性能调优实战 AI 与实践欢迎交流与讨论！" }, { "title": "cursor白嫖", "url": "/posts/free-cursor/", "categories": "AI", "tags": "cursor, 白嫖", "date": "2021-10-08 09:36:00 +0800", "snippet": "Cursor 白嫖策略cursor-fake-machine 实现白嫖这个插件可以改变Cursor的机器码，让它以为你在不同的电脑上登录，从而绕过额度限制。 首先，需要下载cursor-fake-machine插件。 下载好之后，打开Cursor，把插件文件直接拖到插件扩展区域就OK了！ 安装成功后，你会看到一个提示，告诉你安装完成了。接下来，就是见证奇...", "content": "Cursor 白嫖策略cursor-fake-machine 实现白嫖这个插件可以改变Cursor的机器码，让它以为你在不同的电脑上登录，从而绕过额度限制。 首先，需要下载cursor-fake-machine插件。 下载好之后，打开Cursor，把插件文件直接拖到插件扩展区域就OK了！ 安装成功后，你会看到一个提示，告诉你安装完成了。接下来，就是见证奇迹的时刻！ 打开Cursor的设置（file-&gt;preference-&gt;cursor settings），找到“advanced-&gt;Manage”，然后进入官网，删除账号。 删除账号后，回到Cursor，退出登录，确保你的账号已经彻底退出了。 在Cursor中，按下快捷键Ctrl+Shift+P，然后输入“fake”，你会看到一个“Fake Cursor”的选项，点击它！ cursor-fake-machine github地址cursor-fake-machine这个方案使用久了，发现有时候还是不能用，会被提示使用太多次，方案二可以接着白嫖白嫖方案二方案来自于 toutiao 参照方案一 去官网删除账号 在powershell 中执行 irm https://raw.githubusercontent.com/yuaotian/go-cursor-help/master/scripts/install.ps1 | iex 运行命令，等待安装完成，重启cursor" }, { "title": "java - 基础知识", "url": "/posts/thread1/", "categories": "java", "tags": "java", "date": "2021-10-08 09:36:00 +0800", "snippet": "内存结构 栈 存放局部变量 堆 存放对象，数组 变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内）四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes       ...", "content": "内存结构 栈 存放局部变量 堆 存放对象，数组 变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内）四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes       default yes yes     protected yes yes yes   public yes yes yes yes 对于class的修饰符只有public 和defaultJavaBean 符合以下标准的类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get,set方法用户可以使用JavaBean 将功能，处理，值，数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet,其他JavaBean,applet程序或者应用来使用这些对象。用户可以认为JavaBean 提供了一种随时随地的复制和赞贴的功能，而不用关心任何改变。this this可以调用属性，方法，构造器 this() 调用构造器，可以显示的使用this(形参列表)方式，调用指定的其他构造器，不能形成递归继承 子类继承后，具有父类的所有属性和方法 ，private属性和方法仍然认为获取到了，但是因为封装的原因，不能直接调用 所有的java类处 java.lang.Object 外，都直接或者间接继承了java.lang.Object类 当子类和父类中定义同名属性时，我们想要在子类调用父类中的属性方式，必须使用“super.属性”，子类不会覆盖父类的属性 我们可以在子类构造器中显示的使用super(形参列表)，调用父类的构造器，必须声明在子类构造器的首行 在构造器的首行没有显示的声明this(形参列表)或super(形参列表)，则默认调用的是父类的空参的构造函数子类对象的实例化过程 从结果来看 子类继承父类以后，就获取了父类所有的属性和方法 创建子类的对象后，在堆空间中，就会加载所有父类中声明的属性 从过程看 当我们通过子类的构造器创建子类对象时，我们一定会直接或者间接的调用父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有父类的结构，所有内存中才会有所有父类的结构，并且使用。 虽然创建子类对象时，调用了父类的构造器，但是只创建了一个对象，就是new 出来的对象多态性 对象的多态性，父类的引用指向子类的对象多态的使用 当调用子父类同名同参方法时，执行的是子类重写父类的方法 编译期，只能调用父类中声明的方法 ，但是运行期，我们实际执行的是子类重写的方法 只适用方法，编译看左边，运行看右边 对象的多态性，只使用于方法，不适用于属性。 编译和运行都看左边。 虚拟方法调用 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它不同子类对象，动态调用属于子类的的该方法，这样的方法调用在编译器是无法确定的。 编译时类型和运行时类型。方法调用是在运行时确定的，动态绑定。 多态是个运行时行为 若子类重写了父类的方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类的的方法转移到子类中。（编译看左边，运行看右边） 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量（编译运行都看左边）## 方法的重写 方法名，形参列表相同 权限修饰符不能小于父类，不能重写private权限的方法 返回值不能大于父类的返回类型， static 方法不涉及到重写静态变量 静态变量随着类的加载而加载 静态变量加载要早于对象的创建 类只会加载一次， 静态变量也只会存在一份静态方法 只能调用静态变量或者其他静态方法，因为是随着类的加载而加载，其他实例变量还没有，所以this,super是不能用的。栈，堆，方法区 栈，静态变量 堆：new 出来的结构 对象，数组 方法区： 类的加载信息，静态域，常量池抽象与接口抽象 抽象类，不可以实例化，一定有构造器，便于子类实例化时调用，通常在开发中，都会提供抽象类的子类，让子类对象实例化。 抽象方法，没有方法体，只有声明。 抽象方法一定是在抽象类。 若子类重写了父类的所有 抽象方法后，则此子类可以实例化，若子类没有重写父类的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰。接口 interface和类是并列的结构，通过implements 如何定义接口：JDK7及以前 只能定义全局常量和抽象方法（public static final（书写时可以省略）,public abstarct） JDK8 新增了 静态方法和默认方法。 接口中是不可以定义构造器的，意味着接口不可以实例化 如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化，如果没有则实现类认为接口 java类可以实现多个接口，弥补了java单继承性 接口与接口之间可以继承，并且可以多继承 ### jdk8 新特性 静态方法和默认方法 接口中定义的静态方法，只能通过接口调用 通过实现类的对象，可以调用接口中的默认方法 如果子类继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数默认（default）方法 接口冲突： 如果实现类实现了多个接口，而这多个接口中定了同名同参数的默认方法，那么实现类没有重写此方法的情况下报错 调用接口中的默认方法 Interface.super.method（）## 抽象类和接口的共同点以及区别 相同点： 不能实例化，都可以被继承 不同 抽象类：有构造器， 接口：不能声明构造器 ，类单继承，接口可以多继承异常处理### ERROR 一般不编写针对性的代码进行处理 java虚拟机无法解决的严重问题，如JVM系统内部错误，资源耗尽等严重情况，例如栈溢出：StackOverflowError,堆溢出：OutOfMemoryError,### Exception 其他编程错误或偶然的外在因素导致的，可以使用针对性的代码进行处理 例如空指针，数组越界，除数为0 一般两种解决方法，遇到错误终止程序的运行。另一种方法时由程序编写程序时，考虑到错误的检测，错误消息的提示，以及处理。 finally 是可选的，finally 中声明的是一定会被执行的代码，即使catch中又出了异常，try中有return语句，catch中有return 语句等， 也会先执行finally的语句。 像数据库连接，输入输出流，网络编程Socket 等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中 ### 体会 使用try-catch-finally 处理编译时异常，是将编译时可能出现的异常，延迟到运行时出现 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时编译try-catch-finally " }, { "title": "java - 设计模式-原型模式", "url": "/posts/designpattern4/", "categories": "java", "tags": "原型模式", "date": "2021-01-08 09:36:00 +0800", "snippet": "原型模式（ProtoType） 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型模式，允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节 工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clonepackage CreationalPattern.ProtoTyp...", "content": "原型模式（ProtoType） 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型模式，允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节 工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clonepackage CreationalPattern.ProtoTypePattern;public class Main { public static void main(String[] args) { ProtoType pt1 =new ProtoType(1); ProtoType pt2 = new ProtoType(2); pt1.setProtoType(pt2); System.out.println(pt1.toString()); try { ProtoType pt3 = (ProtoType) pt1.clone(); System.out.println(pt3.toString()); }catch (Exception e) { System.out.println(e.getMessage()); } }}package CreationalPattern.ProtoTypePattern;/** * 原型模式 */public class ProtoType implements Cloneable { public int id; public void setProtoType(ProtoType protoType) { this.protoType = protoType; } private ProtoType protoType; public ProtoType(int id) { this.id = id; } @Override public String toString() { return \"id:\"+id+\" protoType:\"+protoType.hashCode(); } @Override protected Object clone() throws CloneNotSupportedException { ProtoType protoType=null; try { protoType = (ProtoType) super.clone(); }catch (Exception e) { System.out.println(e.getMessage()); } return protoType; }}输出结果id:1 protoType:603742814id:1 protoType:603742814对于引用传递的对象再克隆的时候，传递的是地址，这里克隆模式使用的是浅拷贝浅拷贝 对于数据类型是基本数据类型的成员变量，直接进行值传递 对于引用类型的成员变量，例如数组，或者成员对象，浅拷贝进行引用传递，也就是只会复制地址，在一个对象修改该成员变量，会影响到另一个对象的该成员变量值深拷贝 复制对象的所有基本数据类型的成员变量值 为所还有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达到所有的对象。深拷贝实现 重写 clone 方法来实现深拷贝 对象序列化实现深拷贝" }, { "title": "java - 类加载过程", "url": "/posts/java1/", "categories": "java", "tags": "类加载过程", "date": "2021-01-03 09:36:00 +0800", "snippet": "类加载过程初始化 一个类要实例化需要先加载并初始化该类 main 所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行&lt; clinit &gt;（） 方法 &lt; clinit &gt;() 方法由静态类静态变量显示赋值代码和静态代码块组成 类变量显示赋值代码和静态代码块从上到下顺序执行 ...", "content": "类加载过程初始化 一个类要实例化需要先加载并初始化该类 main 所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行&lt; clinit &gt;（） 方法 &lt; clinit &gt;() 方法由静态类静态变量显示赋值代码和静态代码块组成 类变量显示赋值代码和静态代码块从上到下顺序执行 &lt; clinit &gt;()方法只执行一次 实例初始化 实例初始化就是执行&lt; init &gt;() 方法 &lt; init &gt;() 方法可能重载有多个，有几个构造器就有几个&lt; init &gt;()方法 &lt; init &gt;() 方法由非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而构造器的代码最后执行 每次创建实例对象，调用对应构造器，执行的就是对应&lt; init &gt;()方法 &lt; init &gt;方法的首行是 super（）或 super（实参列表），即对应父类&lt; init &gt;方法方法的重写 不可重写的方法 final 方法 静态方法 private 等子类中不可见方法 非静态方法前面都有个 this，this 在&lt; init &gt; 表示的是正在创建的对象对象的多态性 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码 非静态方法默认的调用对象时 this this 堆在在构造器或者说&lt; init &gt;方法中就是正在创建的队形" }, { "title": "设计模式 - 单例", "url": "/posts/designpattern3/", "categories": "设计模式", "tags": "单例", "date": "2020-12-20 09:36:00 +0800", "snippet": "单例模式采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）八种方式 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举饿汉式（静态常量）1.构造器私有化（防止 new 出新实例） 2.类的...", "content": "单例模式采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）八种方式 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举饿汉式（静态常量）1.构造器私有化（防止 new 出新实例） 2.类的内部创建对象 3.向外暴露一个静态方法（获取实例）public class Singleton7{ private Singleton7() { } private static class SingletonInstance{ private static final Singleton7 INSTANCE = new Singleton7(); } public static Singleton7 getInstance() { return SingletonInstance.INSTANCE; }}优点：写法简单，类装载的时候完成实例化，避免线程安全问题缺点：类装载的时候完成实例化，没有 lazy loading 效果，如果自始至终没有用到单例，会造成内存浪费这种方式基于 classloader 机制避免了多线程的同步问题，不过，intance 在装载时就实例化，单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因很多，不能确定有其他的方式导致类装载，这时候初始化 instance 没有达到 lazy loading 的效果。饿汉式（静态代码块）packagepattern.Singleton;/** * 饿汉式 静态代码块 */public class Singleton2 { private Singleton2() { } private static Singleton2 instance; static { instance = new Singleton2(); } public static Singleton2 getInstance() { return instance; }}类实例化的过程放在了静态代码块中，也是类装载的时候，就执行了静态代码块的中的代码，初始化类的实例。优缺点和上面相同。懒汉式（线程不安全）/** * 懒汉式 线程不安全 lazy loading */public class Singleton3 { private Singleton3() { } private static Singleton3 instance; public static Singleton3 getInstance() { if(instance==null){ instance = new Singleton3(); } return instance; }}1.起到了 lazy loading 的效果，但是只能单线程下使用. 2.如果在多线程下，多个线程同时进入 if 语句，就会产生多个实例饿汉式（线程安全）/** * 懒汉式，线程安全，同步方法 */public class Singleton4 { private Singleton4() { } private static Singleton4 instance; public static synchronized Singleton4 getInstance() { if(instance==null){ instance = new Singleton4(); } return instance; }}优点：线程安全缺点：效率太低，每个线程想要获取实例执行 getInstance 都要进行同步，但是该方法只需要执行一次，实例化后直接 return 就好了实际开发不推荐双重检查/** * Double Check 双重检查 * 优点： 线程安全，懒加载，getInstance方法效率也提高了 */public class Singleton6 { private Singleton6() { } private static volatile Singleton6 instance; public static Singleton6 getInstance() { if(instance==null){ synchronized(Singleton6.class) { if(instance==null) { instance = new Singleton6(); } } } return instance; }}推荐使用的方法优缺点：线程安全，延迟加载，效率较高第一个 instance==null 不为空则直接返回，避免方法每次访问同步第二个 instance==null 保证了线程安全这样保证了效率和线程安全，在实际开发中推荐这样使用静态内部类/** * 静态内部类方法 */public class Singleton7{ private Singleton7() { } private static class SingletonInstance{ private static final Singleton7 INSTANCE = new Singleton7(); } public static Singleton7 getInstance() { return SingletonInstance.INSTANCE; }}1.这种方式采用了类装载的机制来保证初始化实例只有一个线程 2.静态内部类在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载静态内部类 SingletonInstance，从而完成 Singleton 的实例化，提高了效率 3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程安全，在类进行初始化时，别的线程是无法进入的，避免线程不安全。推荐使用总结 单例模式保证系统中该类只有这一个对象，节省了系统资源，对于频繁创建销毁的对象，使用单例模式可以系统性能 当想使用一个实例时，只能用 getInstance，不能 new 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象工具类对象，频繁访问数据库或文件的对象（比如数据源，session 工厂等）" }, { "title": "设计模式 - 设计模式的原则", "url": "/posts/designpattern2/", "categories": "设计模式", "tags": "设计模式的原则", "date": "2020-12-06 09:36:00 +0800", "snippet": "七大原则单一职责原则单一职责原则（Single Responsibility Principle, SRP）： 一个类只负责一个功能领域中的相 应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。开闭原则开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件 实体应尽量在不修改原有代码的情况下进行扩展。在 Java、C...", "content": "七大原则单一职责原则单一职责原则（Single Responsibility Principle, SRP）： 一个类只负责一个功能领域中的相 应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。开闭原则开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件 实体应尽量在不修改原有代码的情况下进行扩展。在 Java、C#等 编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现 层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系 统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何 改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩 展系统的功能，达到开闭原则的要求。里式替换原则里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类 （父类）的地方必须能透明地使用其子类的对象。里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对 象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用 子类对象来替换父类对象。(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代 换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在 子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现 父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地 扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类 来实现。里氏代换原则是开闭原则的具体实现手段之一。依赖倒转原则依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应 当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据 类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只 实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增 加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体 类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭 原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发 生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注 入，设值注入（Setter 注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象， 设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务 方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型 的对象，由子类对象来覆盖父类对象。接口隔离原则接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干 不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具 有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义， 有严格的定义和结构，比如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以 及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概 念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角 色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端 需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的 所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口 中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便， 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只 包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即 为不同的客户端提供宽窄不同的接口。合成复用原则合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复 用的目的。合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些 已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能 的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低 类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使 用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂 度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继 承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是 静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新 对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现 细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对 较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用 成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型 相同的其他对象。迪米特原则迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪 米特法则中，对于一个对象，其朋友包括以下几类： (1) 当前对象本身(this)； (2) 以参数形式传入到当前对象方法中的对象； (3) 当前对象的成员对象； (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； (5) 当前对象所创建的对象。" }, { "title": "Akka 入门-Actor", "url": "/posts/akka1/", "categories": "框架", "tags": "akka, actor", "date": "2020-10-17 00:16:00 +0800", "snippet": "模块AKKA 是调度模块化的，它由许多拥有不同特性的 JAR 组成。 akka-actor – 经典角色、类型角色、IO 角色等。 akka-agent – 代理、整合了 Scala 的 STM 特性 akka-camel – 整合 Apache 的 Camel akka-cluster – 集群成员管理、弹性路由 akka-kernel – AKKA 微内核，运行着一个极简应用服...", "content": "模块AKKA 是调度模块化的，它由许多拥有不同特性的 JAR 组成。 akka-actor – 经典角色、类型角色、IO 角色等。 akka-agent – 代理、整合了 Scala 的 STM 特性 akka-camel – 整合 Apache 的 Camel akka-cluster – 集群成员管理、弹性路由 akka-kernel – AKKA 微内核，运行着一个极简应用服务器 akka-osgi – 在 OSG 容器里使用 AKKA 的基本 bundle，包括 akka-actor 的类 akka-osgi-aries – Aries——服务提供角色系统的蓝图 akka-remote – 远程角色 akka-slf4j – SLF4J Logger (事件总线监听器) akka-testkit – 测试角色系统的工具包 Toolkit for testing Actor systems akka-zeromq – 整合 ZeroMActor 角色（Actor） 并发与并行性的高等级抽象 异步，无锁以及高性能的事件驱动编程模型 非常轻量级的事件驱动流程 容错 拥有“让它崩溃”语义的管理层级 管理层级可以跨越多个 JVM，实现真正的容错系统 非常适合编写可自我修复且永不停机的高容错能力的系统 位置透明 akka 旨在分布式环境中工作：角色之间都是用纯消息交互，并且一切都是异步的 Actor 优点 事件驱动模型：Event-driven model，Actor 通过响应消息来执行工作。Actor 之间的通信是异步的，允许 Actor 发送消息并继续自己的工作，而不是阻塞等待响应 强隔离原则：Strong isolation principles，与 Java 中的常规对象不同，Actor 在调用的方法方面，没有一个公共 API。相反，它的公共 API 是通过 Actor 处理的消息来定义的。这可以防止 Actor 之间共享状态；观察另一个 Actor 状态的唯一方法是向其发送请求状态的消息。 位置透明：Location transparency，系统通过工厂方法构造 Actor 并返回对实例的引用。因为位置无关紧要，所以 Actor 实例可以启动、停止、移动和重新启动，以向上和向下扩展以及从意外故障中恢复 轻量级：Lightweight，每个实例只消耗几百个字节，这实际上允许数百万并发 Actor 存在于一个应用程序中。Actor 生命周期actor 被创建后存在，并且用户请求关闭消失。当 actor 被关闭后，其所有的子 actor 都将被递归地关闭。这个特性极大简化了我们的资源清理工作，并且防止资源泄露。实际上，在进行底层多线程编程时，我们经常会小看各种对并发资源生命周期管理的难度。Context.stop(self)自我关闭，停止其他 Context.stop(actorRef) 通过这种方式停止一个 actor 是坏习惯，但是你可以给这个 actor 发送 PosionPill 或者自定义关闭消息来关闭它。Akka 的 actor 提供了很对生命周期 API，你可以在实现 actor 时重载这些方法。最常用的是 preStart()和 postStop()。preStart()会在 actor 启动后，并在它处理第一个消息之前被调用postStop()会在 actor 将要被关闭前被调用，在它之后，actor 不会再处理任何消息了Actor 层次结构通过调用 context.actorOf 创建一个 actor。这种方式向现有的 actor 树内加入了一个新的 actor，这个 actor 创建者就成为了这个 actor 的父 actor。所有的 actor 都有一个共同的家长 成为 user guardian 可以通过调用 system.actorOf()来创建属于它新的 actor 实例。创建 actor 将返回一个有效的 URL 引用，因此，如果我们通过调用 system.actorOf(…,”someActor”) 创建一个名为 someActor 时，其引用将包路径/user/someActorActor 失败处理父 actor 和子 actor 在整个声明周期内都保持着联系。当一个 actor 失败了（抛出异常或者在 receive 里冒出一个未处理的异常），他会被暂时地挂起。就像之前提到的一样，失败信息会被传递到父 actor 中，然后由父 actor 来决定如何处理这个子 actor 产生的异常。在这种方式下，父 actor 就是子 actor 的监管者，默认的监管策略就是停止并且重启子 actor。如果你没有修改默认的监管策略，那么所有的失败都会导致重启 actor。到在 actor 失败后，被监管的 actor 被立即停止并重启，我们也看到了一条这个异常被处理的日志。在测试中，我们使用 preStart()和 postStop()钩子，这些钩子可以在 actor 被重启前后被调用，所以我们不能用它来区分 actor 是我吃一次启动还是被重启。重启 actor 在大多数情况是正确的，重启可以让 actor 恢复到一个已知的正确状态上，也就是启动时的干净状态。在内部真正发生的是：preRestart()和postRestart() 方法被调用，如果它们没有被重载，则它们分别会调用 postStop()和 preStart()你可以尝试重载这些方法，看看输出的改变Actor 处理子角色故障角色最后一个功能是处理子角色的故障。故障处理对于用户来说是透明的，对于发生的故障 Akka 都会自动的通过对应策略处理（监管和监测章节介绍）。 因为这些策略是构成角色系统的基础，所以一旦角色被创建那么这些故障处理策略将不可改变。由于每个角色都只有一类故障处理策略，这也就意味着不同的子角色将会应用不同的策略。角色根据子角色所使用的故障处理策略将它们分组。根据任务被切分的子任务性质系统会不断的重复这个分组过程。一旦角色终止，如失败后无法重启，自己停止或者被监督者停止，那么它将释放它占有的所有资源，并将它信箱中没处理的消息发送到“死信件信箱”里，然后“死信件信箱”将会把他们以 DeadLetters 的形式传递给 EventStream. Actor 引用中的信箱将会被一个系统信箱所取代，然后将所有消息以 DeadLetters 的形式转发给 EventStream。虽然系统会尽最大努力来实现该消息传递，但是我们不能依赖它来实现“有保证的传递”。为什么不选择悄悄的将所有消息倾倒出来，是基于我们下面的测试结果考虑：我们在事件总线（BUS）上注册了测试事件监听器(TestEventListener)。这里事件总线即死信件被发送到的地方。该监听器将会对收到的每条死信件记录一条警告日志——这个可以帮助我们更快的检测失败。所以我们有理由相信这个特征还将可以应用于其他目的。" }, { "title": "常用算法 一", "url": "/posts/datastructure11/", "categories": "数据结构与算法", "tags": "java", "date": "2020-07-12 14:16:00 +0800", "snippet": "常用算法非递归二分查找实现二分查找只适用于有序查找，需要先将数列进行排序package com.learn.bsc;/** * 非递归二分查找 */public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int ...", "content": "常用算法非递归二分查找实现二分查找只适用于有序查找，需要先将数列进行排序package com.learn.bsc;/** * 非递归二分查找 */public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int right = arr.length -1; while(left&lt;=right) { int mid =(left+right)/2; if(arr[mid]==target) { return mid; }else if(arr[mid]&gt;target) { right=mid-1; }else { left=mid+1; } } return -1; }}分治算法分治算法可以求解的一些问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔分治算法设计模式分治算法实现汉诺塔这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体package com.learn.fenzhi;public class hannoitower{// 把n-1个盘子由A 移到 B；// 把第n个盘子由 A移到 C；// 把n-1个盘子由B 移到 C；public static void play(int num,char a,char b,char c) { if(num==1) { //只有一个盘直接从a移到c System.out.println(\"第一个盘从\"+a+\"-&gt;\"+c); }else{ //盘&gt;=2 总是看成两个盘 //把最上面的盘全部移到b play(num-1,a,c,b); System.out.println(\"第\"+num+\"个盘从\"+a+\"-&gt;\"+c); //把b上面移到c play(num-1,b,a,c); } }}" }, { "title": "常用算法 一", "url": "/posts/algorithm1/", "categories": "数据结构与算法", "tags": "java", "date": "2020-07-10 14:16:00 +0800", "snippet": "常用算法非递归二分查找实现二分查找只适用于有序查找，需要先将数列进行排序package com.learn.bsc;/** * 非递归二分查找 */public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int ...", "content": "常用算法非递归二分查找实现二分查找只适用于有序查找，需要先将数列进行排序package com.learn.bsc;/** * 非递归二分查找 */public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int right = arr.length -1; while(left&lt;=right) { int mid =(left+right)/2; if(arr[mid]==target) { return mid; }else if(arr[mid]&gt;target) { right=mid-1; }else { left=mid+1; } } return -1; }}分治算法分治算法可以求解的一些问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔分治算法设计模式分治算法实现汉诺塔这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体package com.learn.fenzhi;public class hannoitower{// 把n-1个盘子由A 移到 B；// 把第n个盘子由 A移到 C；// 把n-1个盘子由B 移到 C；public static void play(int num,char a,char b,char c) { if(num==1) { //只有一个盘直接从a移到c System.out.println(\"第一个盘从\"+a+\"-&gt;\"+c); }else{ //盘&gt;=2 总是看成两个盘 //把最上面的盘全部移到b play(num-1,a,c,b); System.out.println(\"第\"+num+\"个盘从\"+a+\"-&gt;\"+c); //把b上面移到c play(num-1,b,a,c); } }}动态规划算法核心思想 将大问题规划分为小问题进行解决，从而一步步虎丘最优解的处理算法 动态规划算反与分治算法类似，其基本思想也是将带球解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解的到原问题的解 与分治法不同的是，适合用于动态规划求解的问题，经分级得到子问题往往不是互相独立的。即下一个阶段的求解是建立在上一阶段的解的基础上进行进一步求解 动态规划可以通过填表方式来逐步推进，得到最优解。背包问题" }, { "title": "图", "url": "/posts/datastructure10/", "categories": "数据结构与算法", "tags": "tree, java", "date": "2020-07-02 14:16:00 +0800", "snippet": "1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中顶点的...", "content": "1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中顶点的集合，E是图 G 中边的集合。1.线性表中数据元素 叫元素 。 树-结点 图-顶点 2.图是有穷非空集合，图结构中不允许没有顶点 3.线性表中，相邻数据元素之间具有线性关系无向边 顶点之间的边没有方向，如果任意两个顶点之间的边都是无向边，则称该图为无向图。若两顶点之间的边有方向，则称这条边为有向边，也称为弧。无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图图的遍历深度优先 （Depth First Search）广度优先 (Braddth FS)深度优先和广度优先，时间复杂度相同，不同之处仅仅在于对顶点访问的顺序不同。package com.learn.graph;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class Graph { private ArrayList&lt;String&gt; vertexList; //存储顶点集合 private int[][] edges; //存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { //测试一把图是否创建ok int n = 8; //结点的个数 //String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E//\t\tgraph.insertEdge(0, 1, 1); // A-B//\t\tgraph.insertEdge(0, 2, 1); ////\t\tgraph.insertEdge(1, 2, 1); ////\t\tgraph.insertEdge(1, 3, 1); ////\t\tgraph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); //测试一把，我们的dfs遍历是否ok System.out.println(\"深度遍历\"); graph.dfs(); // A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]//\t\tSystem.out.println(); System.out.println(\"广度优先!\"); graph.bfs(); // A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8] } //构造器 public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w /** * * @param index * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) { for(int j = 0; j &lt; vertexList.size(); j++) { if(edges[index][j] &gt; 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for(int j = v2 + 1; j &lt; vertexList.size(); j++) { if(edges[v1][j] &gt; 0) { return j; } } return -1; } //深度优先遍历算法 //i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w != -1) {//说明有 if(!isVisited[w]) { dfs(isVisited, w); } //如果w结点已经被访问过 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } //对一个结点进行广度优先遍历的方法 private void bfs(boolean[] isVisited, int i) { int u ; // 表示队列的头结点对应下标 int w ; // 邻接结点w //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while( !queue.isEmpty()) { //取出队列的头结点下标 u = (Integer)queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while(w != -1) {//找到 //是否访问过 if(!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w); //体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } //图中常用的方法 //返回结点的个数 public int getNumOfVertex() { return vertexList.size(); } //显示图对应的矩阵 public void showGraph() { for(int[] link : edges) { System.err.println(Arrays.toString(link)); } } //得到边的数目 public int getNumOfEdges() { return numOfEdges; } //返回结点i(下标)对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; }}" }, { "title": "二叉排序树 BST（Binary Sort Tree）", "url": "/posts/datastructure9/", "categories": "数据结构与算法", "tags": "tree, java", "date": "2020-07-02 14:16:00 +0800", "snippet": "二叉排序树二叉排序树是一颗空树或者具有以下性质二叉树 若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值 若它的右子树不为空，则右子树上所欲结点的值均大于它根结点的值 它的左右子树分别为二叉排序树实现package com.learn.bst;public class BinarySortTreeDemo { public static void main(String...", "content": "二叉排序树二叉排序树是一颗空树或者具有以下性质二叉树 若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值 若它的右子树不为空，则右子树上所欲结点的值均大于它根结点的值 它的左右子树分别为二叉排序树实现package com.learn.bst;public class BinarySortTreeDemo { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点到二叉排序树 for(int i = 0; i&lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } //中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树~\"); binarySortTree.infixOrder(); // 1, 3, 5, 7, 9, 10, 12 //测试一下删除叶子结点 binarySortTree.delNode(12); binarySortTree.delNode(5); binarySortTree.delNode(10); binarySortTree.delNode(2); binarySortTree.delNode(3); binarySortTree.delNode(9); binarySortTree.delNode(1); binarySortTree.delNode(7); System.out.println(\"root=\" + binarySortTree.getRoot()); System.out.println(\"删除结点后\"); binarySortTree.infixOrder(); }}//创建二叉排序树class BinarySortTree { private Node root; public Node getRoot() { return root; } //查找要删除的结点 public Node search(int value) { if(root == null) { return null; } else { return root.search(value); } } //查找父结点 public Node searchParent(int value) { if(root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while(target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if(root == null) { return; }else { //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if(targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if(root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if(targetNode.left == null &amp;&amp; targetNode.right == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if(parent.left != null &amp;&amp; parent.left.value == value) { //是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) {//是由子结点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { //删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的结点 //如果要删除的结点有左子结点 if(targetNode.left != null) { if(parent != null) { //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { //如果要删除的结点有右子结点 if(parent != null) { //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) { parent.left = targetNode.right; } else { //如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } //添加结点的方法 public void add(Node node) { if(root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if(root != null) { root.infixOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } }}//创建Node结点class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } //查找要删除的结点 /** * * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if(value == this.value) { //找到就是该结点 return this; } else if(value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 //如果左子结点为空 if(this.left == null) { return null; } return this.left.search(value); } else { //如果查找的值不小于当前结点，向右子树递归查找 if(this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if(value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); //向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); //向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } //添加结点的方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if(node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if(node.value &lt; this.value) { //如果当前结点左子结点为null if(this.left == null) { this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { //添加的结点的值大于 当前结点的值 if(this.right == null) { this.right = node; } else { //递归的向右子树添加 this.right.add(node); } } } //中序遍历 public void infixOrder() { if(this.left != null) { this.left.infixOrder(); } System.out.println(this); if(this.right != null) { this.right.infixOrder(); } }}平衡二叉树（AVL 树）平衡二叉树时一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1定义：它时一颗空树或它的左右两个子树的高度差绝对值不超过 1，并且左右两个子树都是一颗平衡二叉树一个 BST 左子树全部为空 从形式上看 更像一个单链表插入速度没有影响，但是查询速度比链表更慢，因为需要判断左子树平衡二叉树是在二叉搜索树的基础之上成立的平衡二叉树常用实现方法有红黑树Avl替罪羊树Treap伸展树右子树高的时候进行左旋，左子树搞得时候进行右旋左旋思路： 1.创建一个新节点，值等于当前根节点的值 2.把新节点的左子树设置成当前节点的左子树 3.把新节点的右子树设置为当前节点的右子节点的左子树 4.把当前节点的值换位右子节点的值 5.把当前节点的左子树设置为新节点 6.把当前节点的右子树设置成当前节点右子树的右子树package com.learn.avl;public class AVLTreeDemo { public static void main(String[] args) { // int[] arr = {4, 3, 6, 5, 7, 8}; int[] arr ={10,12,8,9,7,6}; AVLTree tree = new AVLTree(); for (int i = 0; i &lt; arr.length; i++) { tree.add(new Node(arr[i])); } System.out.println(tree.height()); }}class AVLTree { private Node root; public Node getRoot() { return root; } public int height() { return root.height(); } //查找要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //查找父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } else { //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) { //是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) {//是由子结点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { //删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的结点 //如果要删除的结点有左子结点 if (targetNode.left != null) { if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { //如果要删除的结点有右子结点 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) { parent.left = targetNode.right; } else { //如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } }} //创建Node结点 class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } /** * 左旋思路： * 1.创建一个新节点，值等于当前根节点的值 * 2.把新节点的左子树设置成当前节点的左子树 * 3.把新节点的右子树设置为当前节点的右子节点的左子树 * 4.把当前节点的值换位右子节点的值 * 5.把当前节点的左子树设置为新节点 * 6.把当前节点的右子树设置成当前节点右子树的右子树 */ public void leftRotate() { Node temp = new Node(this.value); temp.left = left; temp.right = right.left; value=right.value; this.left=temp; right=right.right; } public void rightRotate() { Node temp = new Node(this.value); temp.right = right; temp.left = left.right; value=left.value; left = left.left; right=temp; } /** * 以本节点为根节点的高度,如果只有根节点，高度则是 1 */ public int height() { int left_height=1; int right_height=1; if(left!=null) { left_height=left.height()+1; } if(right!=null) { right_height=right.height()+1; } return Math.max(left_height,right_height); } /** * 右子树高度 * @return */ public int rightHeight() { int mHeight= 0; if(right!=null) { return right.height(); } return mHeight; } /** * 左子树高度 * @return */ public int leftHeight() { int mHeight =0; if (left!=null) { return left.height(); } return mHeight; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) { //找到就是该结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 //如果左子结点为空 if (this.left == null) { return null; } return this.left.search(value); } else { //如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); //向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); //向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } //添加结点的方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { //如果当前结点左子结点为null if (this.left == null) { this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { //添加的结点的值大于 当前结点的值 if (this.right == null) { this.right = node; } else { //递归的向右子树添加 this.right.add(node); } } if(rightHeight()-leftHeight()&gt;1) { if(right!=null&amp;&amp;right.leftHeight()&gt;right.rightHeight()) { right.rightRotate(); } leftRotate(); return; } if(leftHeight()-rightHeight()&gt;1) { if(left!=null&amp;&amp;left.rightHeight()&gt;left.leftHeight()) { left.leftRotate(); } rightRotate(); } } //中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } }多路查找树多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点可以存储多个元素。由于它时查找树，所有元素之间存在某种特定的排序关系多路查找树 4 中特殊形式 2-3 树，2-3-4 树，b 树，b+树在二叉树中，每个节点有数据项，最多两个子节点，如果允许每个节点有更多的数据项和更多的子节点，就是多叉树2-3 树其中每一个结点都具有两个孩子或者三个孩子一个 2 节点包含一个元素和两个孩子或者没有孩子一个 3 结点包含一小一大两个元素和三个孩子或者没有孩子2=3 树所有叶子节点都在同一层（只要是 B 树都满足这个条件）2-3 树是由 2，3 结点构成的B 树B 树是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。节点最大的孩子数目称为 B 树的阶 因此 2-3 树是 3 阶的 B 树，2-3-4 树是 4 阶的 B 树。一个 m 阶的 b 树具有如下属性如果根结点不是叶子结点，则至少有两颗子树每一个非根的分支节点都有 k-1 个元素和 k 个孩子，其中 m/2&lt;=k&lt;=m每一个叶子节点 n 都有 k-1 个元素，其中 m/2&lt;=k&lt;=m.所有叶子节点都位于同一层次B 树上查找的过程式一个顺指针查找结点和再结点中查找关键字的交叉过程B 树是怎么做到减少内存与外存交换数据的外存，比如硬盘，将所有信息分割成相等大小的页面，每次硬盘读写都是一个或多个完整的页面，对于一个硬盘来说，一页的长度可能是 211 到 214 个字节。在一个典型的 B 树应用中，要处理的硬盘数据量很大，因此无法一次全部装入到内存。因此我们会对 B 树进行调整，使得 B 树的阶数（结点的元素）与硬盘存储的页面大小相匹配。通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数据量的数据。由于 b 树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，b 树的数据结构就是为内外存的数据交互准备的。B+树对于树结构来说，我们可以通过中序遍历来顺序查找树中的元素，这一切都是在内存中进行。可是在 b 树结构中，我们往返于每个节点之间意味着，我们必须得在硬盘的页面之间进行多次访问。为了能够解决所有元素遍历等基本问题，我们在原有的 B 树结构基础上，加上了新的元素组织方式，这就是 B+树。B+树是应文件系统所需而出的一种 B 树的变形树，严格意义上讲，不是数据结构定义的树了。" }, { "title": "赫夫曼树", "url": "/posts/datastructure8/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-23 14:16:00 +0800", "snippet": "赫夫曼树树的带权路径长度：树的带权路径长度规定为所有的叶子节点的带权路径长度之和（wpl 的和），wpl 最小的树就是赫夫曼树给定 n 个权值作为 n 个叶子节点，构造一颗二叉树，若该树的带权路径达到最小（wpl），这样的二叉树称为最优二叉树。赫夫曼树是带权路径最短的树，权越大离根结点距离越近构建赫夫曼树构建赫夫曼树的思路 从小到大进行排序，每个数据看成一个节点，每个节点看成最简单的二叉树...", "content": "赫夫曼树树的带权路径长度：树的带权路径长度规定为所有的叶子节点的带权路径长度之和（wpl 的和），wpl 最小的树就是赫夫曼树给定 n 个权值作为 n 个叶子节点，构造一颗二叉树，若该树的带权路径达到最小（wpl），这样的二叉树称为最优二叉树。赫夫曼树是带权路径最短的树，权越大离根结点距离越近构建赫夫曼树构建赫夫曼树的思路 从小到大进行排序，每个数据看成一个节点，每个节点看成最简单的二叉树 取出根节点权重值最小的两颗二叉树 组成一颗新的二叉树，新的二叉树的根节点权值是前面两颗二叉树的根节点权值的和 再将这颗新的二叉树，以根节点的权值大小再次排序 不断重复 1-4 的步骤，直到数列中，所有的数据都被处理。就得到一颗赫夫曼树。package com.learn.huffman;import java.util.ArrayList;import java.util.Collections;public class HuffmanTree { public static void main(String[] args) { int[] arr=new int[]{13,7,8,3,29,6,1}; createHuffManTree(arr); } //创建赫夫曼树 public static void createHuffManTree(int[] arr) { ArrayList&lt;Node&gt; nodes=new ArrayList&lt;Node&gt;(arr.length); for(int i=0;i&lt;arr.length;i++) { nodes.add(new Node(arr[i])); } while (nodes.size()&gt;1) { //排序 Collections.sort(nodes); Node leftNode =nodes.get(0); Node rightNode = nodes.get(1); Node root= new Node(leftNode.value+rightNode.value); root.left=leftNode; root.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(root); } //前序遍历 nodes nodes.get(0).preOrder(); }}class Node implements Comparable&lt;Node&gt;{ int value; Node left; Node right; public Node(int value) { this.value = value; } public void setLeft(Node left) { this.left = left; } public void setRight(Node right) { this.right = right; } public int getValue() { return value; } public Node getLeft() { return left; } public Node getRight() { return right; } /** * 前序遍历 */ public void preOrder() { System.out.println(this.toString()); if(left!=null) { left.preOrder(); } if(right!=null) { right.preOrder(); } } @Override //从小到大排序 public int compareTo(Node o) { return this.value-o.value; } @Override public String toString() { return this.value+\"\"; }}赫夫曼编码 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一 赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在 20%~90%之间 赫夫曼码是可变字长编码（vlc）的一种赫夫曼编码实现 前缀编码：字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码，即不能匹配到重复的编码 根据赫夫曼树，给各个字符，规定编码，向左的路径为 0，向右为 1 ，前缀编码，匹配的时候不会出现多意性（因为每一个字符都有唯一路径）package com.learn.huffmancode;import java.util.*;//赫夫曼编码实现public class huffManCodeDemo { public static void main(String[] args) { String str = \"i like like like java do you like a java\"; huffManCode tree = new huffManCode(str.getBytes()); HashMap&lt;Byte, String&gt; huffmanCodes = tree.getHuffManCode(); var bytes = huffManZip(str.getBytes(),huffmanCodes); System.out.println( new String(decode(bytes,huffmanCodes)) ); } /** * 解压缩赫夫曼编码后的byte数组 * 1.将byte还原成二进制字符串 * @param byteArr byteArr是将赫夫曼表，按字符顺序对应的二进制字符串按8位组成一个byte存储后的数组，最后一位不够8位则高位补0 * @param huffManCodes 对应的哈夫曼编码表 * @return */ public static byte[] decode(byte[] byteArr,HashMap&lt;Byte,String&gt; huffManCodes) { //转置哈夫曼编码 HashMap&lt;String,Byte&gt; reverseHuffManCodes = new HashMap&lt;&gt;(); for(Map.Entry&lt;Byte,String&gt; entry:huffManCodes.entrySet()) { reverseHuffManCodes.put(entry.getValue(),entry.getKey()); } StringBuilder bitString =new StringBuilder(); for(int i=0;i&lt;byteArr.length;i++) { bitString.append(byteToBitString(i!=byteArr.length-1,byteArr[i])); } int mark =0; List&lt;Byte&gt; lst= new ArrayList&lt;&gt;() ; for(int i=0;i&lt;bitString.length();i++) { var temp=reverseHuffManCodes.get(bitString.substring(mark,i)); if(temp!=null) { lst.add(temp); mark=i; } } lst.add(reverseHuffManCodes.get(bitString.substring(mark))); byte[] original = new byte[lst.size()]; for(int i=0;i&lt;lst.size();i++) { original[i]=lst.get(i); } return original; } /** * 将一个byte转成二进制的字符串 * @param flag 是否需要进行补位，如果是最后一个字节不需要补高位 * @return */ public static String byteToBitString(boolean flag,byte b) { int temp =b; if(flag) { temp |=256; } String bitString = Integer.toBinaryString(temp); if(flag) { bitString = bitString.substring(bitString.length()-8); } return bitString; } /** * @param bytes 需要压缩byte【】 * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = \"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ public static byte[] huffManZip( byte[] bytes,HashMap&lt;Byte, String&gt; huffmanCodes) { StringBuilder builder = new StringBuilder(); //获取每个字符对应的赫夫曼路径编码 for (var b : bytes) { builder.append(huffmanCodes.get(b)); } String huffStr = builder.toString(); int len = (huffStr.length() + 7) / 8; byte[] zipBytes = new byte[len]; //每8位二进制转成一个byte类型数据 //获取长度 int index = 0; for (int i = 0; i &lt; huffStr.length(); i += 8) { String byteStr; if ((i + 8) &lt; huffStr.length()) { byteStr = huffStr.substring(i, i + 8); } else { byteStr = huffStr.substring(i); } zipBytes[index] = (byte)Integer.parseInt(byteStr,2); index++; } return zipBytes; }}/** * 将字符串转成哈夫曼编码 */class huffManCode { //根节点 Node root; HashMap&lt;Byte, String&gt; huffCodeMap = new HashMap&lt;Byte, String&gt;(); /** * 把所有字符转换成哈夫曼树节点形式 * * @param bytes 目标字符串 * @return 所欲节点列表 */ ArrayList&lt;Node&gt; createNodeLst(byte[] bytes) { ArrayList&lt;Node&gt; arrayList = new ArrayList&lt;&gt;(); HashMap&lt;Byte, Node&gt; nodeDictionary = new HashMap&lt;Byte, Node&gt;(); for (int i = 0; i &lt; bytes.length; i++) { Byte data = bytes[i]; Node node = nodeDictionary.get(data); if (node == null) { node = new Node(bytes[i], 0); node.data = data; node.weight++; nodeDictionary.put(data, node); } else { node.weight++; } } for (var nodeSet : nodeDictionary.entrySet()) { arrayList.add(nodeSet.getValue()); } return arrayList; } public huffManCode(byte[] bytes) { ArrayList&lt;Node&gt; nodes = createNodeLst(bytes); while (nodes.size() &gt; 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node root = new Node(null, left.weight + right.weight); root.lNode = left; root.rNode = right; nodes.remove(left); nodes.remove(right); nodes.add(root); } root = nodes.get(0); } public void print() { System.out.println(getHuffManCode()); } public HashMap&lt;Byte, String&gt; getHuffManCode() { getHuffManCode(root, \"\", new StringBuilder()); return huffCodeMap; } void getHuffManCode(Node node, String code, StringBuilder builder) { StringBuilder tempBulider = new StringBuilder(builder); tempBulider.append(code); if (node != null) { //找到叶子节点 if (node.data == null) { //向左0 向右 1 getHuffManCode(node.lNode, \"0\", tempBulider); getHuffManCode(node.rNode, \"1\", tempBulider); } else { huffCodeMap.put(node.data, tempBulider.toString()); } } }}class Node implements Comparable&lt;Node&gt; { //字符 Byte data; //权值 public int weight = 0; //左子结点 Node lNode; //右子结点 Node rNode; public Node(Byte data, int weight) { this.data = data; this.weight = weight; } public Node getlNode() { return lNode; } public void setlNode(Node lNode) { this.lNode = lNode; } public Node getrNode() { return rNode; } public void setrNode(Node rNode) { this.rNode = rNode; } @Override public int compareTo(Node o) { return this.weight - o.weight; }}赫夫曼编码压缩数据注意事项 如果文件本身已经是经过压缩处理的，那么使用赫夫曼编码再压缩效率会不明显，比如压缩视频，ppt 等 赫夫曼编码是按字节处理的，因此可以处理所有文件（二级制文件，文本文件） 如果一个文件重复的内容不是很多，压缩效果也不会很明显" }, { "title": "树", "url": "/posts/datastructure7/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-18 11:16:00 +0800", "snippet": "树与数组链表的比较数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低树存储方式分析提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率二叉树 每个节点最多只有两个...", "content": "树与数组链表的比较数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低树存储方式分析提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率二叉树 每个节点最多只有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且节点总数 2^n-1 n 为层数，则我们称为满二叉树 如果该二叉树所有叶子节点都在最后一层或者倒数第二次，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树相关概念 节点 根节点 父节点 子节点 叶子节点（没有子节点） 节点的权 路径（从 root 节点找到该节点的路线） 层 子树 树的高度(最大层数) 森林（多颗子树构成森林）遍历二叉树遍历（父节点输出位置对应了 前序 中序 后序 ，左子树始终比右子树先输出） 前序遍历： 先输出父节点，再遍历左子树和右子树 中序遍历：先遍历左子树，再输出父节点，再遍历右子树 后续遍历：先遍历左子树，再遍历右子树，最后输出父节点查询与删除遍历类似public static void main(String[] args) { HeroTree heroTree = new HeroTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"宋江\"); HeroTreeNode node2 = new HeroTreeNode(2, \"吴用\"); HeroTreeNode node3 = new HeroTreeNode(3, \"卢俊义\"); HeroTreeNode node4 = new HeroTreeNode(4, \"林冲\"); HeroTreeNode node5 = new HeroTreeNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); heroTree.setRoot(root); heroTree.DelNode(2); //测试\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 heroTree.preOrder();//// //测试//\t\tSystem.out.println(\"中序遍历\");//\t\theroTree.midOrder(); // 2,1,5,3,4////\t\tSystem.out.println(\"后序遍历\");// heroTree.postOrder(); // 2,5,4,3,1// HeroTreeNode node = heroTree.PostSearch(5);// if(node!=null)// {// node.ToString();// }else {// System.out.println(\"target node is null\");// } }}class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } }}class HeroTreeNode{ public int id; public String name; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; }顺序存储二叉树应用:堆排序从数据存储来看，树的存储方式与数组的存储方式可以互相转换二叉树的节点以数组方式存放，并且仍然可以进行前序遍历，中序遍历，和后序遍历顺序存储二叉树的特点 顺序二叉树通常指考虑完全二叉树 第 n 个元素的左子节点为 2*n+1 第 n 个元素的右子节点为 2*n+2 第 n 元素的父节点为（n-1）/2n 表示二叉树的第几个元素（从 0 开始)线索化二叉树1.n 个节点的二叉链表中含有 2n-(n-1)=n+1 个空指针，利用二叉树链表中的空指针域，存放指向节点在某种遍历顺序下的前驱和后继节点的指针 2.这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树和后序线索二叉树三种 3.一个节点的前一个节点，称为前驱节点 4.一个节点的后一个节点，称为后继节点优点 创建线索化二叉树时可以充分利用空指针域 通过前驱后继，可以快速索引节点，不必再次遍历线索化二叉树以及遍历线索化二叉树package com.learn.tree;public class BinaryTree{ public static void main(String[] args) { ThreadedBinaryTree heroTree = new ThreadedBinaryTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"tom\"); HeroTreeNode node2 = new HeroTreeNode(3, \"jack\"); HeroTreeNode node3 = new HeroTreeNode(6, \"smith\"); HeroTreeNode node4 = new HeroTreeNode(8, \"mary\"); HeroTreeNode node5 = new HeroTreeNode(10, \"king\"); HeroTreeNode node6 = new HeroTreeNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); heroTree.setRoot(root); heroTree.Threaded(); // System.out.print(node2.leftType+\" \"+node2.rightType); heroTree.ThreadedList(); // node4.ToString(); // System.out.print(node4.leftType); // heroTree.DelNode(2); //测试//\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4// heroTree.preOrder();//// //测试//\t\tSystem.out.println(\"中序遍历\");//\t\theroTree.midOrder(); // 2,1,5,3,4////\t\tSystem.out.println(\"后序遍历\");// heroTree.postOrder(); // 2,5,4,3,1// HeroTreeNode node = heroTree.PostSearch(5);// if(node!=null)// {// node.ToString();// }else {// System.out.println(\"target node is null\");// } }}class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } }}class HeroTreeNode{ public int id; public String name; //节点类型 public int leftType = 0; public int rightType =0 ; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; }}//中序线索化二叉树class ThreadedBinaryTree extends HeroTree{ HeroTreeNode pre=null; public void Threaded() { Threaded(root); } public void Threaded(HeroTreeNode node) { if(node==null) { return; } Threaded(node.left); //线索化前驱节点 if(node.left==null) { node.left=pre; //指定type node.leftType=1; } if(pre!=null &amp;&amp; pre.right==null) { pre.right=node; pre.rightType=1; } pre=node; Threaded(node.right); } public void ThreadedList() { HeroTreeNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.leftType == 0) { node = node.left; } //打印当前这个结点 node.ToString(); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.rightType == 1) { //获取到当前结点的后继结点 node = node.right; node.ToString(); } //替换这个遍历的结点 node = node.right; } }}" }, { "title": "树", "url": "/posts/datastructure/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-18 11:16:00 +0800", "snippet": "树与数组链表的比较数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低树存储方式分析提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率二叉树 每个节点最多只有两个...", "content": "树与数组链表的比较数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低树存储方式分析提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率二叉树 每个节点最多只有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且节点总数 2^n-1 n 为层数，则我们称为满二叉树 如果该二叉树所有叶子节点都在最后一层或者倒数第二次，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树相关概念 节点 根节点 父节点 子节点 叶子节点（没有子节点） 节点的权 路径（从 root 节点找到该节点的路线） 层 子树 树的高度(最大层数) 森林（多颗子树构成森林）遍历二叉树遍历（父节点输出位置对应了 前序 中序 后序 ，左子树始终比右子树先输出） 前序遍历： 先输出父节点，再遍历左子树和右子树 中序遍历：先遍历左子树，再输出父节点，再遍历右子树 后续遍历：先遍历左子树，再遍历右子树，最后输出父节点查询与删除遍历类似public static void main(String[] args) { HeroTree heroTree = new HeroTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"宋江\"); HeroTreeNode node2 = new HeroTreeNode(2, \"吴用\"); HeroTreeNode node3 = new HeroTreeNode(3, \"卢俊义\"); HeroTreeNode node4 = new HeroTreeNode(4, \"林冲\"); HeroTreeNode node5 = new HeroTreeNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); heroTree.setRoot(root); heroTree.DelNode(2); //测试\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 heroTree.preOrder();//// //测试//\t\tSystem.out.println(\"中序遍历\");//\t\theroTree.midOrder(); // 2,1,5,3,4////\t\tSystem.out.println(\"后序遍历\");// heroTree.postOrder(); // 2,5,4,3,1// HeroTreeNode node = heroTree.PostSearch(5);// if(node!=null)// {// node.ToString();// }else {// System.out.println(\"target node is null\");// } }}class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } }}class HeroTreeNode{ public int id; public String name; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; }顺序存储二叉树应用:堆排序从数据存储来看，树的存储方式与数组的存储方式可以互相转换二叉树的节点以数组方式存放，并且仍然可以进行前序遍历，中序遍历，和后序遍历顺序存储二叉树的特点 顺序二叉树通常指考虑完全二叉树 第 n 个元素的左子节点为 2*n+1 第 n 个元素的右子节点为 2*n+2 第 n 元素的父节点为（n-1）/2n 表示二叉树的第几个元素（从 0 开始)线索化二叉树1.n 个节点的二叉链表中含有 2n-(n-1)=n+1 个空指针，利用二叉树链表中的空指针域，存放指向节点在某种遍历顺序下的前驱和后继节点的指针 2.这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树和后序线索二叉树三种 3.一个节点的前一个节点，称为前驱节点 4.一个节点的后一个节点，称为后继节点优点 创建线索化二叉树时可以充分利用空指针域 通过前驱后继，可以快速索引节点，不必再次遍历线索化二叉树以及遍历线索化二叉树package com.learn.tree;public class BinaryTree{ public static void main(String[] args) { ThreadedBinaryTree heroTree = new ThreadedBinaryTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"tom\"); HeroTreeNode node2 = new HeroTreeNode(3, \"jack\"); HeroTreeNode node3 = new HeroTreeNode(6, \"smith\"); HeroTreeNode node4 = new HeroTreeNode(8, \"mary\"); HeroTreeNode node5 = new HeroTreeNode(10, \"king\"); HeroTreeNode node6 = new HeroTreeNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); heroTree.setRoot(root); heroTree.Threaded(); // System.out.print(node2.leftType+\" \"+node2.rightType); heroTree.ThreadedList(); // node4.ToString(); // System.out.print(node4.leftType); // heroTree.DelNode(2); //测试//\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4// heroTree.preOrder();//// //测试//\t\tSystem.out.println(\"中序遍历\");//\t\theroTree.midOrder(); // 2,1,5,3,4////\t\tSystem.out.println(\"后序遍历\");// heroTree.postOrder(); // 2,5,4,3,1// HeroTreeNode node = heroTree.PostSearch(5);// if(node!=null)// {// node.ToString();// }else {// System.out.println(\"target node is null\");// } }}class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } }}class HeroTreeNode{ public int id; public String name; //节点类型 public int leftType = 0; public int rightType =0 ; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; }}//中序线索化二叉树class ThreadedBinaryTree extends HeroTree{ HeroTreeNode pre=null; public void Threaded() { Threaded(root); } public void Threaded(HeroTreeNode node) { if(node==null) { return; } Threaded(node.left); //线索化前驱节点 if(node.left==null) { node.left=pre; //指定type node.leftType=1; } if(pre!=null &amp;&amp; pre.right==null) { pre.right=node; pre.rightType=1; } pre=node; Threaded(node.right); } public void ThreadedList() { HeroTreeNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.leftType == 0) { node = node.left; } //打印当前这个结点 node.ToString(); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.rightType == 1) { //获取到当前结点的后继结点 node = node.right; node.ToString(); } //替换这个遍历的结点 node = node.right; } }}" }, { "title": "哈希表", "url": "/posts/datastructure6/", "categories": "数据结构与算法", "tags": "hashmap", "date": "2020-06-17 11:16:00 +0800", "snippet": "哈希表根据关键码值（key value）而直接进行访问的数据结构它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表。常见的哈希表结构数组+链表数组+二叉树哈希表可以同时管理多条链表package com.learn.hash;import java.util.Scanner;public class HashTab { p...", "content": "哈希表根据关键码值（key value）而直接进行访问的数据结构它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表。常见的哈希表结构数组+链表数组+二叉树哈希表可以同时管理多条链表package com.learn.hash;import java.util.Scanner;public class HashTab { public static void main(String[] args) { //创建哈希表 HashTable hashTab = new HashTable(7); //写一个简单的菜单 String key = \"\"; Scanner scanner = new Scanner(System.in); while(true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); //创建 雇员 Emp emp = new Emp(id, name); hashTab.Add(emp); break; case \"list\": hashTab.List(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); //hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } }}class HashTable{ EmpLinkedList[] empLinkedListArray; private int size; public HashTable(int size) { empLinkedListArray =new EmpLinkedList[size]; for(int i=0;i&lt;size;i++) { EmpLinkedList list =new EmpLinkedList(); empLinkedListArray[i]=list; } this.size=size; } public void Add(Emp value) { EmpLinkedList list = empLinkedListArray[HashFun(value.id)]; list.Add(value); } //散列函数 public int HashFun(int id) { return id%size; } public void List() { for(int i=0;i&lt;empLinkedListArray.length;i++) { empLinkedListArray[i].List(); } }}class Emp{ public int id; public String name; public Emp(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } public Emp next;}class EmpLinkedList{ public Emp head; public EmpLinkedList() { head=new Emp(0,null); } public void Add(Emp value) { Emp temp = head; while(temp.next!=null) { temp = temp.next; } temp.next=value; } //list 所有元素 public void List() { Emp temp=head.next; while (temp!=null) { temp.ToString(); temp=temp.next; } }}" }, { "title": "排序算法", "url": "/posts/datastucture5/", "categories": "数据结构与算法", "tags": "sort, java", "date": "2020-06-11 11:16:00 +0800", "snippet": "排序1.内部排序 将需要处理的所有数据都加载到内部存储器中进行排序 2.外部排序法 数据量过大，无法全部加载到内存内部排序 插入排序 直接插入排序 希尔排序 选择排序 简单排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 技术排序冒泡排序int[] arr= ...", "content": "排序1.内部排序 将需要处理的所有数据都加载到内部存储器中进行排序 2.外部排序法 数据量过大，无法全部加载到内存内部排序 插入排序 直接插入排序 希尔排序 选择排序 简单排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 技术排序冒泡排序int[] arr= new int[]{2,5,8,0}; int temp =0; int count = arr.length-1; for (int j=1;j&lt;=count;j++) { for (int i = 0; i &lt; arr.length - j; i++) { if (arr[i] &gt; arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } for (var val:arr ) { System.out.println(val); }进行优化，如果排序已经在完成，则不在继续int[] arr= new int[]{2,5,8,0}; int temp =0; int count = arr.length-1; boolean flag=false; for (int j=1;j&lt;=count;j++) { //优化 某一次已经完成排序了，则不在进行排序 flag=false; for (int i = 0; i &lt; arr.length - j; i++) { if (arr[i] &gt; arr[i + 1]) { flag=true; temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } if(!flag){ break; } } for (var val:arr ) { System.out.println(val); }选择排序第一次从 arr[0]-arr[n-1]选取最小值与 arr[0]交换，第二次从 arr[1]-arr[n-1]选取最小值和 arr[1]交换，通过 n-1 次，获取到有序的队列for(int i=0;i&lt;arr.length;i++) { for(int j=i;j&lt;arr.length;j++) { if(arr[i]&gt;arr[j]) { int temp =arr[i]; arr[i] = arr[j]; arr[j]=temp; } } }插入排序把 n 个带排序元素看成一个有序表和无需表，开始有序表只有一个元素，无序表包含 n-1 个元素，排序过程中每次去无序表中取一个元素，向有序表中寻找合适位置插入 //插入排序实现 public static void Sort(int[] arr) { int val =0; //记录插入的位置 boolean flag =false; int index =0; //外层遍历有序列表 for(int i=1;i&lt;arr.length;i++) { val =arr[i]; //初始插入位置 index=i-1; //内层遍历有序列表，寻找插入位置 while (index&gt;=0&amp;&amp;val&gt;arr[index]) { arr[index+1]=arr[index]; index--; } arr[index+1]=val; } }希尔排序 缩小增量排序希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止，希尔排序对直接插入进行了优化。//移位法 public static void InsertSort2(int[] arr) { for(int gap=arr.length/2;gap&gt;0;gap/=2) { for(int i=gap;i&lt;arr.length;i++) { int index = i; int val = arr[i]; // if(arr[i]&lt;arr[index-gap]) { while (index - gap &gt;= 0 &amp;&amp; val &lt; arr[index-gap]) { arr[index] = arr[index - gap]; index -= gap; } //} arr[index]=val;// for(int j=i-gap;j&gt;=0;j-=gap)// {// if(arr[j]&gt;arr[j+gap])// {// temp=arr[j];// arr[j]=arr[gap+j];// arr[gap+j]=temp;// }// } } } }快速排序快速排序是对冒泡排序的改进，采用分治的思想 //快速排序 public void QuickSort(int[] arr) { QuickSort(arr,0,arr.length-1); } //快速排序 public void QuickSort(int[] arr,int left,int right) { int pivot = partion(arr,left,right); if(left&lt;right) { QuickSort(arr, left, pivot - 1); QuickSort(arr, pivot + 1, right); } } public int partion(int arr[],int left,int right) { int key =arr[left]; while(left&lt;right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) { right--; } arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt;= key) { left++; } arr[right]=arr[left]; } arr[left]=key; return left; }排序速度堆排序堆：是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，反之则是小顶堆。堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn),它也是不稳定排序，一般升序采用大顶堆，降序采用小顶堆堆排序思想：将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点，将它与堆数组的末尾元素进行交换，此时末尾元素就是最大值，然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值，如此反复就能得到一个有序序列。//编写一个堆排序的方法 public static void heapSort(int arr[]) { int temp = 0; System.out.println(\"堆排序!!\");//\t\t//分步完成//\t\tadjustHeap(arr, 1, arr.length);//\t\tSystem.out.println(\"第一次\" + Arrays.toString(arr)); // 4, 9, 8, 5, 6////\t\tadjustHeap(arr, 0, arr.length);//\t\tSystem.out.println(\"第2次\" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for(int i = arr.length / 2 -1; i &gt;=0; i--) { adjustHeap(arr, i, arr.length); }\t\t/*\t\t * 2).将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端;　　\t\t\t3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。\t\t */ for(int j = arr.length-1;j &gt;0; j--) { //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } //System.out.println(\"数组=\" + Arrays.toString(arr)); } //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = {4, 6, 8, 5, 9}; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 {4, 9, 8, 5, 6} * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 {4, 9, 8, 5, 6} =&gt; {9,6,8,5, 4} * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) { int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for(int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) { if(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) { //说明左子结点的值小于右子结点的值 k++; // k 指向右子结点 } if(arr[k] &gt; temp) { //如果子结点大于父结点 arr[i] = arr[k]; //把较大的值赋给当前结点 i = k; //!!! i 指向 k,继续循环比较 } else { break;//! } } //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 }}" }, { "title": "递归", "url": "/posts/datastructure4/", "categories": "数据结构与算法", "tags": "recursion, java", "date": "2020-06-05 10:36:00 +0800", "snippet": "递归 -自己调用自己的函数使用场景 8 皇后，汉诺塔，阶乘，迷宫 快排，归并，二分，分治 使用栈解决的问题-&gt;递归代码比较简洁使用递归需要遵守的问题 执行一个方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量是独立的，不会相互影响 每个递归定义至少必须有一个条件，满足时递归不再进行，而是返回值退出 遵守谁调用，就将结果返回谁，方法执行完毕或者返回时，该方法也...", "content": "递归 -自己调用自己的函数使用场景 8 皇后，汉诺塔，阶乘，迷宫 快排，归并，二分，分治 使用栈解决的问题-&gt;递归代码比较简洁使用递归需要遵守的问题 执行一个方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量是独立的，不会相互影响 每个递归定义至少必须有一个条件，满足时递归不再进行，而是返回值退出 遵守谁调用，就将结果返回谁，方法执行完毕或者返回时，该方法也就执行完毕 如果方法中，用到引用类型的变量，则会共享迷宫回溯1.成功条件 是终点可以走的通 即状态 2 2.中间有个分支如果出现走不通，即开始回溯，分支即判断 false，所有分支都判断为 false 则该点 即为 3 3.递归至终点，并且可以走通，回溯完成当前路径，则是行的通的路径package com.learn.recursion;//迷宫回溯public class Maze { public static void main(String[] args) { //数组标记 0 可走节点 ，1 障碍物， 2 走的通的节点 ，3 走不通的节点 var map = CreateMaze(6,7); int sizeX=map.length; int sizeY=map[0].length; //设置障碍 map[2][1]=1; map[2][2]=1; //开始走出迷宫 GoMaze(map,1,1); for(int i=0;i&lt;sizeX;i++) { for (int j = 0; j &lt; sizeY; j++) { System.out.print(map[i][j]+\" \"); } System.out.println(); } } //创建迷宫 public static int[][] CreateMaze(int sizeX,int sizeY) { int[][] map= new int[sizeX][sizeY]; for(int i=0;i&lt;sizeX;i++) for(int j=0;j&lt;sizeY;j++) { if(i==0||i==sizeX-1||j==0||j==sizeY-1) { map[i][j]=1; }else{ map[i][j]=0; } } return map; } //走出迷宫 //策略 下-&gt;右-&gt;上-&gt;左 /* *x,y开始节点 map迷宫 */ public static boolean GoMaze(int[][] map,int sx,int sy) { for(int i=0;i&lt;6;i++) { for (int j = 0; j &lt; 7; j++) { System.out.print(map[i][j]+\" \"); } System.out.println(); } System.out.println(\"-----------------------------------------\"); //终止循环 if(map[4][5]==2) { return true; }else { if(map[sx][sy]==0) { map[sx][sy]=2; if(GoMaze(map,sx+1,sy)) { return true; }else if(GoMaze(map,sx,sy+1)) { return true; }else if(GoMaze(map,sx-1,sy)) { return true; }else if(GoMaze(map,sx,sy-1)) { return true; } map[sx][sy]=3; return false; }else { return false; } } }}8 皇后问题算法（回溯算法）思路 第一个皇后放在第一行第一列 第二个皇后放在第二行第一列，判断是否 ok，如果不 ok 则继续往第二列第三列放 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放在第一个列时的正确解将全部得到 后续依次将第一个皇后放在第二列，第三列。。。 这里用一维数组表示棋盘 e.g arr[] ={1,1},下表表示 index+1 行，对应的值表示 value+1 列实现package com.learn.recursion;//8皇后问题public class Queen { public static void main(String[] args) { Queen8 queen8=new Queen8(); queen8.StarPut(); }}class Queen8{ //皇后数量 int queen_num=8; int[] arr=new int[queen_num]; public void StarPut() { PutQueen(0); } //放入棋子 public void PutQueen(int n) { //n==8 即第九行的棋子，前面8个符合8皇后规则 if(n==queen_num) { //递归完成，打印当前的棋子 Log(); return; } for(int i=0;i&lt;queen_num;i++) { //把棋子放在第n+1行的第i+1列 arr[n]=i; //如果符合 8皇后规则 if(Check(n)) { //则继续放下一行 PutQueen(n+1); } } } //判断当前放入的列是否符合规则 public boolean Check(int n) { for(int i=0;i&lt;n;i++) { //arr[i]==arr[n] 列值相等 //Math.abs(arr[i]-arr[n]在对角线上 if(arr[i]==arr[n]||Math.abs(n-i)==Math.abs(arr[i]-arr[n])) { return false; } } return true; } //输出值 public void Log() { for(int i=0;i&lt;queen_num;i++) { System.out.print(arr[i]+\" \"); } //h换行 System.out.println(); }}" }, { "title": "栈", "url": "/posts/datastructure3/", "categories": "数据结构与算法", "tags": "stack, java", "date": "2020-06-05 10:36:00 +0800", "snippet": "栈 先入后出的有序列表 （FILO-First In Last Out） 栈是限制线性表中元素的插入和删除 只能在线性表一段进行的特殊线性表，允许插入和删除的一端称为栈顶，另一端为栈底 最先放入栈中元素在栈底，最后放入的元素在栈顶，删除则是最后放入的先删除，最先放入的最后删除。栈涉及到的应用场景 子程序调用：在跳往子程序前，会先将下个指令的地址存放到堆栈中，子程序执行完毕后，从堆栈取...", "content": "栈 先入后出的有序列表 （FILO-First In Last Out） 栈是限制线性表中元素的插入和删除 只能在线性表一段进行的特殊线性表，允许插入和删除的一端称为栈顶，另一端为栈底 最先放入栈中元素在栈底，最后放入的元素在栈顶，删除则是最后放入的先删除，最先放入的最后删除。栈涉及到的应用场景 子程序调用：在跳往子程序前，会先将下个指令的地址存放到堆栈中，子程序执行完毕后，从堆栈取出指令地址，回到之前程序 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数，区域变量等数据存入堆栈 表达式的转换 [中缀表达式转后缀表达式]与求值 二叉树遍历 图形深度优先搜索算法（depth-first）栈实现的计算器package com.learn.stack;///计算表达式public class Caculator { public static void main(String[] args) { String exp = \"3+2*6-5\"; int index =0; Stack numStack = new Stack(10); Stack expStack =new Stack(10); for(int i=0;i&lt;exp.length();i++) { char c = exp.substring(i,i+1).charAt(0); //数栈 符号栈 if(IsOper(c)) { if(expStack.IsEmpty()) { expStack.Push(c); }else if(OperPriority(expStack.Peek()) &lt;=OperPriority(c)) { expStack.Push(c); }else { int value =Oper(numStack,expStack); numStack.Push(value); expStack.Push(c); } }else{ //char 转 int (ascii) numStack.Push(c-48); } } //遍历完成后进行运算 while(true) { if(expStack.IsEmpty()) break; int value = Oper(numStack,expStack); System.out.println(\"value=\"+value); numStack.Push( value); } System.out.printf(\"The result of expression %s is %d\",exp,numStack.Peek()); } //是否为运算符 public static boolean IsOper(int oper) { if(oper=='*'||oper=='/'||oper=='+'||oper=='-') { return true; } return false; } //运算符优先级 public static int OperPriority(int oper) { if(oper=='*'||oper=='/') { return 2; }else if (oper=='+'||oper=='-') { return 1; } return 0; } //运算规则 public static int Oper(Stack numStack,Stack expStack) { int num1 = numStack.Pop(); int num2 = numStack.Pop(); int exp =expStack.Pop(); int value=0; //num2 先入栈 运算时从左至右，num2在前 switch (exp) { case '*': value=num2*num1; break; case '/': value=num2/num1; break; case '+': value=num2+num1; break; case '-': value=num2-num1; break; } return value; }}//数组实现栈class Stack { //最大栈 private int maxSize; //指示当前栈顶位置 int top = -1; int[] stack; public Stack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } //栈是否已满 public boolean IsFull() { return maxSize == top + 1; } //栈是否是空的 public boolean IsEmpty() { return top == -1; } //出栈 public int Pop() { if (IsEmpty()) { throw new RuntimeException(\"The stack is Empty\"); } int val = stack[top]; top--; return val; } //压栈 public void Push(int value) { if (IsFull()) { System.out.println(\"the stack is full push fail\"); return; } top++; stack[top] = value; } //查询栈顶信息 public int Peek() { if(IsEmpty()) { throw new RuntimeException(\"empty stack\"); } return stack[top]; } //遍历栈 public void Show() { if (IsEmpty()) { return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } }}" }, { "title": "链表", "url": "/posts/datastructure2/", "categories": "数据结构与算法", "tags": "linkedlist, java", "date": "2020-06-03 10:36:00 +0800", "snippet": "链表 链表是以节点方式存储 每个节点包含 data，next 域指向下一个节点 链表的各个节点不一定是连续存储 链表根据需求，可以带头结点也可以不带尾部插入package com.learn.linkedlist;public class SingleLinkedListDemo { public static void main(String[] args){ ...", "content": "链表 链表是以节点方式存储 每个节点包含 data，next 域指向下一个节点 链表的各个节点不一定是连续存储 链表根据需求，可以带头结点也可以不带尾部插入package com.learn.linkedlist;public class SingleLinkedListDemo { public static void main(String[] args){ SingleLinkedList linkedList = new SingleLinkedList(); for (int i=1;i&lt;=10;i++) { HeroNode node = new HeroNode(i,\"nick\"+i); linkedList.Add(node); } linkedList.List(); }}class HeroNode{ int no; String nickName; HeroNode next; public HeroNode(int no,String nickName) { this.no=no; this.nickName=nickName; } public void ToString() { System.out.print(\"no=\"+no+\" nickName=\"+nickName+\" \"); }}class SingleLinkedList{ //头结点 固定，不可更改 HeroNode head=new HeroNode(0,null); //添加节点 public void Add(HeroNode node) { HeroNode tmp = head; while (true) { if(tmp.next==null) { tmp.next=node; break; } tmp=tmp.next; } } //显示所有的节点 public void List() { HeroNode tmp=head; while(true) { if(tmp==null) { break; } tmp.ToString(); tmp=tmp.next; } }}删除节点只需要将目标节点的上一节点的 next 指向目标节点的 next，即可删除目标节点 //删除目标节点 public void Delete(int no) { HeroNode tmp = head.next; while(true) { if(tmp==null || tmp.next==null) { break; }else if(tmp.next.no==no) { tmp.next=tmp.next.next; break; } //后移 tmp=tmp.next; } }获取有效节点个数 public int GetLength() { HeroNode cur =head.next; int length=0; while(cur!=null) { length++; cur=cur.next; } return length; }获取倒数第 K 个节点相当于获取有效节点个数后，减去 k 后即正序的节点public HeroNode getReverseNode(int index) { int size =GetLength(); if(index&gt;size || index&lt;0) { return null; } int reverse_index=size-index; HeroNode tar =head.next; while(true) { if(tar==null) { break; } reverse_index--; if(reverse_index==0) { break; } tar=tar.next; } return tar; }单链表反转 简单面试题思路： 新增头节点 遍历旧链表所有节点 每次遍历出的节点，都往新链表的头部插入 将原来链表头结点，指向新链表的头结点public void Reverse() { HeroNode reverseHead= new HeroNode(0,null); HeroNode tmp = head.next; while (tmp!=null) { HeroNode next_tmp= tmp.next; tmp.next = reverseHead.next; reverseHead.next=tmp; tmp=next_tmp; } head.next=reverseHead.next; }双向链表双向链表是单链表扩展出来的结构，很多操作相同。例如获取长度，查找元素。由于多了一个指向前驱元素的指针，在添加和删除时，向对于单链表会增加对前驱指针的操作。与单向链表对比 单项链表，查找方向只能是一个方向，双向链表可以向前或者向后查找 单项链表不能自我删除，需要辅助接点，而双向链表，则可以自我删除（单向链表删除时总是需要一个辅助节点，这个节点是待删除节点的前一个节点） 多存储了一个指针，内存消耗增加。环形链表创建 借助辅助指针 first ，记录第一个节点，只有一个节点时，自己指向自己，形成闭环 cur 记录最后一次添加的节点，cur 指向新增节点，新增节点 next 指向 first//添加节点 public void Add(CNode cNode) { if(first==null) { first = cNode; first.next=first; } //将最后一个添加的节点后继指向新节点 if(cur != null) { cur.next=cNode; } //形成闭环 cNode.next=first; //记录节点 cur=cNode; }遍历环形链表public void List() { //空表 if(first==null) { return; } CNode tmp = first; while (true) { tmp.ToString(); if(tmp.next==first) { break; } tmp=tmp.next; } }约瑟夫问题helper 类似于单链表删除节点时辅助节点，first 指向需要删除节点，helper 用于删除和判断循环结束条件/** * 约瑟夫问题 * @param k 起始位置 * @param m 间隔 */ public void JosePhu(int k,int m) { //helper始终first的前一个元素 CNode helper=first; while (true) { //定位helper //只有一个元素时first == helper if(helper.next==first) { break; } helper=helper.next; } //定位helper和first初始位置，从第k个开始,需要移动k-1次 for(int i=1;i&lt;=k-1;i++) { helper=helper.next; first=first.next; } //开始做出队处理，直到只剩下一个元素 while(true) { if(helper==first) { helper.ToString(); break; } for(int j=1;j&lt;=m-1;j++) { helper=helper.next; first=first.next; } first.ToString(); first = first.next; helper.next=first; } }" }, { "title": "稀疏数组与队列", "url": "/posts/datastructure1/", "categories": "数据结构与算法", "tags": "sparsearray, queue", "date": "2020-06-01 17:36:00 +0800", "snippet": "参考资料：https://space.bilibili.com/302417610?spm_id_from=333.788.b_765f7570696e666f.2线性结构与非线性结构线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构 顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储...", "content": "参考资料：https://space.bilibili.com/302417610?spm_id_from=333.788.b_765f7570696e666f.2线性结构与非线性结构线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构 顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息 线性结构常见的有 一维数组 队列 链表 栈非线性结构 多维数组（包括二维），广义表，树 ，图稀疏数组当一个数组中大部分元素是 0，或者相同的值，可以使用稀疏数组来保存处理方法：记录数组一共有几行几列，有多少个不同的值把具有不同值得元素的行列及值记录在一个小规模数组中（稀疏数组），从而缩小程序的规模.队列队列队列是个有序列表，可以用数组或者链表显示遵循先入先出 （栈是先入后出），即存是加在队列尾部，取从数据头部数组实现队列 front 随着数据输出改变，rear 随着数据输入改变数组实现队列当前实现的队列是不能复用的，数组再使用一次后，不能重复添加using UnityEngine;namespace DataStructure { public class ArrayQueue { int max_size; int rear=-1; //指向数据输入前一位 int front = -1;//指向数据输入后一位 GameObject[] arr;//实现用的数组 //Consturctor public ArrayQueue(int size) { max_size = size; arr= new GameObject[size]; } public bool IsEmpty() { if(front==rear) { return true; } return false; } public bool IsFull() { return max_size&lt;=front+1; } public bool Add(GameObject go) { if(IsFull()) { Debug.LogError(\"Queue is Full\"); return false; } rear++; //超过上限 if(rear&gt;=arr.Length) { return false; } arr[rear]=go; return true; } public GameObject Get() { if(IsEmpty()) { Debug.LogError(\"Queue is Empty\"); return null; } front++; return arr[front]; } public GameObject GetTop() { if(IsEmpty()) { Debug.LogError(\"Queue is Empty\"); return null; } return arr[front+1]; } }}数组模拟环形队列当队列为空时 front==rear，当队列满时，保留一个元素空间，也就是队列满时，数组中还有一个空闲单元 1.判断队列空 front==rear 2.判断队列满 (rear+1)%maxsize=front 3.队列有效长度（rear-front+maxsize）%maxsize" }, { "title": "shader 2d 影子", "url": "/posts/shader26/", "categories": "unity", "tags": "shader, 例子", "date": "2020-05-29 10:36:00 +0800", "snippet": "shader 简单应用 2d 影子uv 翻转 v 后,采样目标纹理,舍弃透明部分，非透明部分按设定颜色输出。Shader \"Custom/ImageEffect/Shadow2d\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _ShadowColor(\"ShadowColor\",Color)=...", "content": "shader 简单应用 2d 影子uv 翻转 v 后,采样目标纹理,舍弃透明部分，非透明部分按设定颜色输出。Shader \"Custom/ImageEffect/Shadow2d\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _ShadowColor(\"ShadowColor\",Color)=(1,1,1,1) } SubShader { Cull Off ZWrite Off ZTest Always Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv =float2(v.uv.x,1-v.uv.y); return o; } sampler2D _MainTex; fixed4 _ShadowColor; fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); clip(col.a-0.1); return _ShadowColor; } ENDCG } }}" }, { "title": "设计模式 - 命令模式", "url": "/posts/designpattern1/", "categories": "设计模式", "tags": "命令模式", "date": "2020-05-28 09:36:00 +0800", "snippet": "命令模式UML 图作用 较容易的实现命令队列 需要的时候可以方便记入日志 接收请求的地方决定是否要接收日志 实现请求的撤销和重做 方便增加新的具体命令类缺点 大量实例化命令实现/// &lt;summary&gt;/// 声明执行操作的接口/// &lt;/summary&gt;abstract public class Command{ //命令接收者 protec...", "content": "命令模式UML 图作用 较容易的实现命令队列 需要的时候可以方便记入日志 接收请求的地方决定是否要接收日志 实现请求的撤销和重做 方便增加新的具体命令类缺点 大量实例化命令实现/// &lt;summary&gt;/// 声明执行操作的接口/// &lt;/summary&gt;abstract public class Command{ //命令接收者 protected CubeReciever reciever; abstract public bool Excute(); abstract public bool Undo();}//子类 ConcreteCommandusing UnityEngine;public class MoveCommand:Command{ Vector2 dir; public MoveCommand( CubeReciever reciever,Vector2 dir) { base.reciever=reciever; this.dir=dir; } public override bool Excute(){ if(reciever==null || dir ==null) { return false; } reciever.CubeAction(dir); return true; } public override bool Undo(){ if(reciever==null || dir==null) { return false; } reciever.CubeAction(-dir); return true; }}using UnityEngine;public class CubeReciever{ public GameObject go; public CubeReciever(GameObject go) { this.go= go; } public void CubeAction(Vector2 dir){ go.transform.localPosition+=new Vector3(dir.x,dir.y,0); }}using System.Collections;using System.Collections.Generic;using UnityEngine;public class PlayInvoker : MonoBehaviour { int command_pos = -1; //命令队列 public List&lt;MoveCommand&gt; commands = new List&lt;MoveCommand&gt; (); public GameObject btn_up; public GameObject btn_down; public GameObject btn_undo; public GameObject btn_redo; private CubeReciever reciever; public GameObject reciever_go; void Awake () { reciever = new CubeReciever (reciever_go); } public void Click (GameObject go) { if (go.Equals (btn_up)) { Vector2 up = new Vector2 (0, 1); Move (up); } else if (go.Equals (btn_down)) { Vector2 down = new Vector2 (0, -1); Move (down); } else if (go.Equals (btn_undo)) { Undo (); } else if (go.Equals (btn_redo)) { Redo (); } } public void Move (Vector2 dir) { MoveCommand command = new MoveCommand (reciever, dir); bool suc = command.Excute (); if (suc) { commands.Add (command); command_pos = commands.Count; } } //实现请求的撤销和重做 public void Undo () { int tar_pos = command_pos - 1; if (tar_pos &gt;= 0 &amp;&amp; tar_pos &lt; commands.Count) { MoveCommand command = commands[tar_pos]; if (command.Undo ()) { command_pos --; } } } //实现请求的撤销和重做 public void Redo () { if(command_pos&lt;commands.Count){ MoveCommand command = commands[command_pos]; if(command.Excute ()) { command_pos++; } } }}" }, { "title": "非真实感渲染（Non-Photorealistic Rendering）", "url": "/posts/shader25/", "categories": "unity", "tags": "shader", "date": "2020-05-18 10:36:00 +0800", "snippet": "卡通风格渲染渲染轮廓线方法 基于观察角度和表面法线的轮廓线渲染 ，视角方向和表面法线点乘结果来得到轮廓线。这种方法简单迅速可以在一个 pass 中就得到渲染结果，但时局限性很大，很多模型得不到满意的描边效果 过程式几何轮廓线渲染，使用两个 pass，一个渲染正面，一个渲染背面，并让轮廓可见。优点快速有效，适用于大部分表面平滑模型，不适合类似于正方体这样平整模型 基于图像处理的轮廓线渲染...", "content": "卡通风格渲染渲染轮廓线方法 基于观察角度和表面法线的轮廓线渲染 ，视角方向和表面法线点乘结果来得到轮廓线。这种方法简单迅速可以在一个 pass 中就得到渲染结果，但时局限性很大，很多模型得不到满意的描边效果 过程式几何轮廓线渲染，使用两个 pass，一个渲染正面，一个渲染背面，并让轮廓可见。优点快速有效，适用于大部分表面平滑模型，不适合类似于正方体这样平整模型 基于图像处理的轮廓线渲染 ，例如使用 sobel 算子的边缘检测，缺点是无法检测深度和法线变化很小的轮廓线，例如桌上的一张纸 基于轮廓边检测的轮廓线渲染，上面的方法无法控制轮廓线的渲染风格。用于精确检测轮廓边并控制渲染风格 \\(( \\vec{n_0} \\cdot \\vec v&gt;0) \\neq (\\vec{n_1} \\cdot \\vecv&gt;0)\\) n0 n1 分别表示这条边相邻两个三角面皮的法线，v 是视角到该变任意顶点的方向顶点扩张在视角空间下把顶点沿法线向往外扩张一段距离，以此来让背部轮廓线可见。但是如果直接对顶点进行扩张，对于一些内凹模型，就会发生背面面片遮挡正面面片的情况为了尽量避免这种情况，在扩张背面顶点之前，先对顶点法线的 z 分量进行一定处理，使他们等于一个定值，然后把法线归一化后进行扩张。 viewNormal.z=-0.5; viewNormal = normalize(viewNormal); viewPos = viewPos +viewNormal*_Outline;添加高光卡通风格渲染中的高光往往是一块分界明显的纯色区域，对于卡通渲染需要的高光反射光照模型，我们会 normalDir 和 halfdir 的点乘结果和一个阈值比较，若小于则高光反射系数 返回 0，否则返回 1。\\[\\mathtt{c}_{specular}=(\\mathtt{c}_{light}\\cdot\\mathtt{m}_{specular})max(0,\\vec n\\cdot\\vec h)^{m_{gloss}}\\]实现\tProperties {\t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1)\t\t_MainTex (\"Main Tex\", 2D) = \"white\" {}\t\t_Ramp (\"Ramp Texture\", 2D) = \"white\" {}\t\t_Outline (\"Outline\", Range(0, 1)) = 0.1\t\t_OutlineColor (\"Outline Color\", Color) = (0, 0, 0, 1)\t\t_Specular (\"Specular\", Color) = (1, 1, 1, 1)\t\t_SpecularScale (\"Specular Scale\", Range(0, 0.1)) = 0.01\t} SubShader {\t\tTags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"}\t\tPass {\t\t\tNAME \"OUTLINE\"\t\t\t//剔除前面，只渲染背面\t\t\tCull Front\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"UnityCG.cginc\"\t\t\tfloat _Outline;\t\t\tfixed4 _OutlineColor;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t};\t\t\tstruct v2f {\t\t\t float4 pos : SV_POSITION;\t\t\t};\t\t\tv2f vert (a2v v) {\t\t\t\tv2f o;\t\t\t\t//视角空间下顶点\t\t\t\tfloat4 pos = mul(UNITY_MATRIX_MV, v.vertex);\t\t\t\t//法线\t\t\t\tfloat3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);\t\t\t\t//扩展前指定 z 的值\t\t\t\tnormal.z = -0.5;\t\t\t\t//延法线方向扩展 顶点\t\t\t\tpos = pos + float4(normalize(normal), 0) * _Outline;\t\t\t\t//顶点变换到裁剪空间\t\t\t\to.pos = mul(UNITY_MATRIX_P, pos);\t\t\t\treturn o;\t\t\t}\t\t\tfloat4 frag(v2f i) : SV_Target {\t\t\t\t//背面颜色指定为轮廓颜色\t\t\t\treturn float4(_OutlineColor.rgb, 1);\t\t\t}\t\t\tENDCG\t\t}\t\tPass {\t\t\tTags { \"LightMode\"=\"ForwardBase\" }\t\t\t//背面已经在上一pass着色\t\t\tCull Back\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#pragma multi_compile_fwdbase\t\t\t#include \"UnityCG.cginc\"\t\t\t#include \"Lighting.cginc\"\t\t\t#include \"AutoLight.cginc\"\t\t\t#include \"UnityShaderVariables.cginc\"\t\t\tfixed4 _Color;\t\t\tsampler2D _MainTex;\t\t\tfloat4 _MainTex_ST;\t\t\t//渐变纹理\t\t\tsampler2D _Ramp;\t\t\tfixed4 _Specular;\t\t\tfixed _SpecularScale;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t\tfloat4 texcoord : TEXCOORD0;\t\t\t\tfloat4 tangent : TANGENT;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : POSITION;\t\t\t\tfloat2 uv : TEXCOORD0;\t\t\t\tfloat3 worldNormal : TEXCOORD1;\t\t\t\tfloat3 worldPos : TEXCOORD2;\t\t\t\tSHADOW_COORDS(3)\t\t\t};\t\t\tv2f vert (a2v v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos( v.vertex);\t\t\t\to.uv = TRANSFORM_TEX (v.texcoord, _MainTex);\t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal);\t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\t\t\t\tTRANSFER_SHADOW(o);\t\t\t\treturn o;\t\t\t}\t\t\tfloat4 frag(v2f i) : SV_Target {\t\t\t\tfixed3 worldNormal = normalize(i.worldNormal);\t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\t\t\t\tfixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));\t\t\t\tfixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);\t\t\t\tfixed4 c = tex2D (_MainTex, i.uv);\t\t\t\tfixed3 albedo = c.rgb * _Color.rgb;\t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;\t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\t\t\t\tfixed diff = dot(worldNormal, worldLightDir);\t\t\t\tdiff = (diff * 0.5 + 0.5) * atten;\t\t\t\tfixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;\t\t\t\tfixed spec = dot(worldNormal, worldHalfDir);\t\t\t\t//邻像素之间近似导数值\t\t\t\tfixed w = fwidth(spec) * 2.0;\t\t\t\tfixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale);\t\t\t\treturn fixed4(ambient + diffuse + specular, 1.0);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Diffuse\"" }, { "title": "Unity Dots", "url": "/posts/shader24/", "categories": "unity", "tags": "dots, ecs", "date": "2020-05-18 10:36:00 +0800", "snippet": "什么是 DOTS充分利用多核处理器，多线程处理让游戏运行速度更快，更高效，DOTS（面向数据的技术堆栈）是以下 3 个系统的集合 Job Systems 任务系统 用于高效运行多线程代码 Entity Component System（ECS）实体组件系统 用于默认编写高新能代码 Burst Compiler burst 编译器 用于生成高度优化的本地代码，Unity 使用 Burst...", "content": "什么是 DOTS充分利用多核处理器，多线程处理让游戏运行速度更快，更高效，DOTS（面向数据的技术堆栈）是以下 3 个系统的集合 Job Systems 任务系统 用于高效运行多线程代码 Entity Component System（ECS）实体组件系统 用于默认编写高新能代码 Burst Compiler burst 编译器 用于生成高度优化的本地代码，Unity 使用 Burst 编译器可以使 C#代码运行效率高于 c++Job Systems 和 ECS 可以独立使用，组合在一起才能发挥最大优势。C# job systems 在 job systems 之前，Unity 内部是多线程处理，但是外部代码必须在主线程上。 c# 虽然支持 thread 但是 Unity 中只能处理数据，例如网络消息，下载，但是不能在 Tread 中调用 Unity API 有了 Job System 可以充分利用多线程，例如在多线程中处理 Transform 旋转，缩放，平移。 Unity 没有直接将 Tread 开放出来，这样可以避免 Tread 滥用，开发者可以放心使用 Job Systems 而不用太关心线程安全，锁 Job System 最好配合 burst 编译器，这样可以生成本地高效代码。 Job System 中的数据类型，只能是值类型（float,int,bool）,enum,struct 和其他类型的指针 Job System 不能使用引用类型，例如 T[] Job 中可以使用 NativeArray代替 T[]HPC# High Performance C# C# class 类型数据的数据内存分配在堆上，程序员无法主动释放，必须等到.NET 进行垃圾回收才会释放。 IL2CPP 虽然将 IL 转成 c++代码，实际上还是模拟了.Net 垃圾回收机制，效率并没有等同与 c++ HPC# 就是 NativeArrary ，NativeHashmap 可替代数组[] 数据类型 包括值类型（float，uint，bool...） NativeArray 可以在 c#层分配 c++中对象，可以主动释放，不需要进行 c#的垃圾回收 Job System 使用的就是 NateiveArrayIJOBPARALLELFOR 并行 IJOB 是一个一个开线程任务，因为数据是顺序执行的，所以它可以保证数据的正确性 使用 IJOBPARALLELFOR 线程是并行执行的，因此数据执行不是顺序执行的，每一个 JOB 数据不能完全依赖上一个 JOB 执行后的结果 “ReadOnly” 意味着数据是只读的，不需要加锁 如果不声明默认数据是 Read/Write，数据一旦改写，Job 一定要等它 Unity 已经为我们做好着些，不需要我们再写加解锁逻辑Unity.MathEMatics 提供矢量类型，可以直接映射到 SIMD 寄存器 有了 SIMD,CPU 可以一次计算 unity 之前的 math 类 默认不支持 simd启动 BurstComile Struct 上加上 BurstCmoplie 标签 Struct 必须继承 IJob,IJobParallelfor，否则无效ECS旧版本的一些总结 设计模式-组件模式 脚本数据在内存中是不连续的 脚本中没必要的数据也提供了，每个 GameObject 都包含了 Transform，这些额外的数据也会占用内存 脚本和脚本是偶尔关系，会出现相互调用 脚本属于引用类型，也就是全局声明的所有变量都会占用堆内存，会产生 GC 脚本是非常重量的产物，手机上挂脚本会额外占用 0.01s 脚本不支持热更新Entity Entity 非常轻量，它就是一个变量 ID，用 int 保存 Entity 可以根据自己需求绑定组件，比如只有位置则只绑定 Position 相同组件会连续排列在内存中，Cache 命中增加，system 遍历速度增加Component 组件是一个简单的数据存储，它时 struct 值类型，并且实现 IComponentData 接口，它不能写方法，没有任何行为，比如 position，rotation struct 中建议使用 float3 代替 vector3，quaternion 代替 Quaternion，原因就是 Unity.MathEMaticsArcheType 原型 Cache 命中增加就得益于 ArcheType ArcheType 是一个容器，并且 Unity 规定每一个大小都是 16kb，不够就再开一个，始终保持内存连续性System System 只关心 Component 组件，它不关心这个 Component 属于哪个 Entity System 系统中定义它所关心的组件，组件都是连续保存在 ArcheType 中的，所以查找速度非常快 System 在 Update 中可以同意更新自己关心的组件ISharedComponentData IComponentData 是结构类型，如果大量结构体中，保存的数据一样，那么在内存中也会产生多分 ISharedComponentData 是共享组件，典型的例子是场景中可能还有很多物体渲染的 mesh 和材质是相同的，如果 IComponentData 是浪费 ISharedComponentData 组件需要实现 IEquatable接口，用于判断两个组件是否相等World World 包含 EntityManager，ComponentSystmes，ArcheTypes EntityManager 包含这个世界里所有的的 Entity，ComponentSystems 则包含世界里所有的组件，ArcheTyps 包含世界里所有的原型 ECS 默认提供了一个世界，我们也可以自己创建 世界与世界不互通，每一个世界都是唯一的，多个世界可以同时并存 World world =new World(“MyWorld”)ECS+JOB+BURST ECS 里的 Component 已经具有超高的 Cache 命中率，性能比传统脚本快很多 ComponentSystem 只能运行在主线程 每一个 ComponentSystem 只能等上一个运行完才能运行自己的 ECS 要配合 job 才能让性能起飞JOBCOMPONENTSYSTEM JobComponentSystem 继承于 ComponentSystem JobComponentSystem 的 update 和 ComponentSystem 一样都是执行完毕一个在执行下一个 区别 JobComponentSystem 的 update 可以很快就返回，将复杂的计算丢给 JOB 去做 通过 Readonly 将 job 标记为是否只读，只读的话 job 是完全可以并行的 如果 job 中某一个数据发生更改，那么这块数据这不能和访问这块数据的其他 job 并行Dots 实践 使用 ComponentDataProxy 可以把一个 struc 绑定在游戏对象上场景导出 ECS PackageManager 添加 Hybrid 组件 Hybrid 的 Scene 组件可以把场景批量转换成 ECS 组件prefab 导出 ECS 保存 Prefab，通过 GameObjectConaversionUtility.ConvertGameObjectHierarchy 直接将 prefab 转成 ECS 对象 prefab 只能是普通的 mesh，如果带骨骼动画不能转成 ECSECS 渲染 ECS 自身是不包含渲染的，但是游戏的渲染和 entity 是密切绑定的 原理大致是通过 ECS 在 JOB 中先准备渲染的数据，然后通过 Gpu instancing 一次渲染，中间不产生 GameObject Gpu instancing 是不带裁剪，并且每帧在 update 里调用，这样会产生额外开销，即使物体不发生位置旋转变化也会强制刷新 建议使用 CommanderBuffer 来渲染 GPU instancing，这样只有物体属性发生改变时强制刷新 使用 BatchRenderGroup 代替 Graphics.DrawMeshInstanced 和 CommandBuffer.DrawMeshInstanced BatchRenderGroup 需要提供每个渲染物体的包围盒区域用户 job 中判断是否在视野范围内 BatchRenderGroup 内都会调自动 GPU Instancing 前提是开启 gpu instancing，并且没有 1023 个数量限制 " }, { "title": "shader入门基础-屏幕后处理效果", "url": "/posts/shader23/", "categories": "unity", "tags": "shader", "date": "2020-05-14 10:00:00 +0800", "snippet": "Unity 中实现屏幕后处理效果在摄像机中添加一个用于屏幕后处理的脚本，在这个脚本中，我们会实现 OnRenderImage 函数来获取当前屏幕的渲染纹理。然后在调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。边缘检测卷积这里本人并不清楚卷积的意义，参考了 CSDN @LianYueBiao 的博客原文参考链接...", "content": "Unity 中实现屏幕后处理效果在摄像机中添加一个用于屏幕后处理的脚本，在这个脚本中，我们会实现 OnRenderImage 函数来获取当前屏幕的渲染纹理。然后在调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。边缘检测卷积这里本人并不清楚卷积的意义，参考了 CSDN @LianYueBiao 的博客原文参考链接图像卷积using UnityEngine;using System.Collections;public class EdgeDetection : PostEffectsBase {\tpublic Shader edgeDetectShader;\tprivate Material edgeDetectMaterial = null;\tpublic Material material {\t\tget {\t\t\tedgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);\t\t\treturn edgeDetectMaterial;\t\t}\t}\t[Range(0.0f, 1.0f)]\tpublic float edgesOnly = 0.0f;\tpublic Color edgeColor = Color.black;\tpublic Color backgroundColor = Color.white;\tvoid OnRenderImage (RenderTexture src, RenderTexture dest) {\t\tif (material != null) {\t\t\tmaterial.SetFloat(\"_EdgeOnly\", edgesOnly);\t\t\tmaterial.SetColor(\"_EdgeColor\", edgeColor);\t\t\tmaterial.SetColor(\"_BackgroundColor\", backgroundColor);\t\t\tGraphics.Blit(src, dest, material);\t\t} else {\t\t\tGraphics.Blit(src, dest);\t\t}\t}}Properties {\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\t\t_EdgeOnly (\"Edge Only\", Float) = 1.0\t\t_EdgeColor (\"Edge Color\", Color) = (0, 0, 0, 1)\t\t_BackgroundColor (\"Background Color\", Color) = (1, 1, 1, 1)\t}\tSubShader {\t\tPass {\t\t\tZTest Always Cull Off ZWrite Off\t\t\t//Blend One OneMinusSrcAlpha\t\t\tCGPROGRAM\t\t\t#include \"UnityCG.cginc\"\t\t\t#pragma vertex vert\t\t\t#pragma fragment fragSobel\t\t\tsampler2D _MainTex;\t\t\t//xxx_TexelSize是Unity为我们提供访问xxx纹理对应的每个纹素大小。\t\t\t//例如一张512X512大小的纹理，则该值为1/512\t\t\t//卷积需要对相邻区域内的纹理进行采样，因此我们需要利用_MainTex_TexelSize来计算各个相邻区域的纹理坐标。\t\t\tuniform half4 _MainTex_TexelSize;\t\t\tfixed _EdgeOnly;\t\t\tfixed4 _EdgeColor;\t\t\tfixed4 _BackgroundColor;\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\thalf2 uv[9] : TEXCOORD0;\t\t\t};\t\t\tv2f vert(appdata_img v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\thalf2 uv = v.texcoord;\t\t\t\t//Sobel算子采样时对应的9个领域纹理坐标\t\t\t\to.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);\t\t\t\to.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);\t\t\t\to.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);\t\t\t\to.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);\t\t\t\to.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);\t\t\t\to.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);\t\t\t\to.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);\t\t\t\to.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);\t\t\t\to.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);\t\t\t\treturn o;\t\t\t}\t\t\t//计算亮度值\t\t\tfixed luminance(fixed4 color) {\t\t\t\treturn 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;\t\t\t}\t\t\t//sobel 算子 滤波？\t\t\t//计算梯度值\t\t\thalf Sobel(v2f i) {\t\t\t\t// const half Gx[9] = {-1, 0, 1,\t\t\t\t// \t\t\t\t\t\t-1, 0, 1,\t\t\t\t// \t\t\t\t\t\t-1, 0, 1};\t\t\t\t// const half Gy[9] = {-1, -1, -1,\t\t\t\t// \t\t\t\t\t\t0, 0, 0,\t\t\t\t// \t\t\t\t\t\t1, 1, 1};\t\t\t\tconst half Gx[9] = {-1, 0, 1,\t\t\t\t\t\t\t\t\t\t-2, 0, 2,\t\t\t\t\t\t\t\t\t\t-1, 0, 1};\t\t\t\tconst half Gy[9] = {-1, -2, -1,\t\t\t\t\t\t\t\t\t\t0, 0, 0,\t\t\t\t\t\t\t\t\t\t1, 2, 1};\t\t\t\thalf texColor;\t\t\t\thalf edgeX = 0;\t\t\t\thalf edgeY = 0;\t\t\t\tfor (int it = 0; it &lt; 9; it++) {\t\t\t\t\ttexColor = luminance(tex2D(_MainTex, i.uv[it]));\t\t\t\t\tedgeX += texColor * Gx[it];\t\t\t\t\tedgeY += texColor * Gy[it];\t\t\t\t}\t\t\t\thalf edge = 1 - abs(edgeX) - abs(edgeY);\t\t\t\treturn edge;//返回梯度值\t\t\t}\t\t\tfixed4 fragSobel(v2f i) : SV_Target {\t\t\t\thalf edge = Sobel(i);\t\t\t\tfixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);\t\t\t\tfixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);\t\t\t\treturn lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); \t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack Off高斯模糊高斯是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程。\\(\\sigma\\) 是标准方差，一般取值 1，x,y 分贝对应了当前位置到卷积核的中心的距离。高斯核的维度越高，模糊的程度越大。使用一个NXN 的高斯核对图像进行卷积滤波，需要 NXNXWXH 次采样，其中 W H 分别对应了图像的宽和高。当 N 增大时，采样次数会急剧增大。我们可以这个二维高斯函数拆成两个一维高斯函数。我们可以使用两个一维的的高斯核先后对图像进行滤波。高斯模糊需要调用两个 Pass,第一个 pass 使用竖直方向一维高斯核进行滤波就，第二个 pass 使用水平方向一维高斯核进行滤波。using UnityEngine;using System.Collections;public class GaussianBlur : PostEffectsBase {\tpublic Shader gaussianBlurShader;\tprivate Material gaussianBlurMaterial = null;\tpublic Material material {\t\tget {\t\t\tgaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);\t\t\treturn gaussianBlurMaterial;\t\t}\t}\t// Blur iterations - larger number means more blur.\t[Range(0, 4)]\tpublic int iterations = 3;\t// Blur spread for each iteration - larger value means more blur\t[Range(0.2f, 3.0f)]\tpublic float blurSpread = 0.6f;\t[Range(1, 8)]\tpublic int downSample = 2;\t/// 1st edition: just apply blur//\tvoid OnRenderImage(RenderTexture src, RenderTexture dest) {//\t\tif (material != null) {//\t\t\tint rtW = src.width;//\t\t\tint rtH = src.height;//\t\t\tRenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);////\t\t\t// Render the vertical pass//\t\t\tGraphics.Blit(src, buffer, material, 0);//\t\t\t// Render the horizontal pass//\t\t\tGraphics.Blit(buffer, dest, material, 1);////\t\t\tRenderTexture.ReleaseTemporary(buffer);//\t\t} else {//\t\t\tGraphics.Blit(src, dest);//\t\t}//\t}\t/// 2nd edition: scale the render texture//\tvoid OnRenderImage (RenderTexture src, RenderTexture dest) {//\t\tif (material != null) {//\t\t\tint rtW = src.width/downSample;//\t\t\tint rtH = src.height/downSample;//\t\t\tRenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);//\t\t\tbuffer.filterMode = FilterMode.Bilinear;////\t\t\t// Render the vertical pass//\t\t\tGraphics.Blit(src, buffer, material, 0);//\t\t\t// Render the horizontal pass//\t\t\tGraphics.Blit(buffer, dest, material, 1);////\t\t\tRenderTexture.ReleaseTemporary(buffer);//\t\t} else {//\t\t\tGraphics.Blit(src, dest);//\t\t}//\t}\t/// 3rd edition: use iterations for larger blur\tvoid OnRenderImage (RenderTexture src, RenderTexture dest) {\t\tif (material != null) {\t\t\t//降采样，采样是原来的 1/downSample ss\t\t\tint rtW = src.width/downSample;\t\t\tint rtH = src.height/downSample;\t\t\tRenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);\t\t\tbuffer0.filterMode = FilterMode.Bilinear;\t\t\tGraphics.Blit(src, buffer0);\t\t\tfor (int i = 0; i &lt; iterations; i++) {\t\t\t\tmaterial.SetFloat(\"_BlurSize\", 1.0f + i * blurSpread);\t\t\t\t//分配一块屏幕大小缓冲区\t\t\t\tRenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);\t\t\t\t// Render the vertical pass\t\t\t\tGraphics.Blit(buffer0, buffer1, material, 0);\t\t\t\t//释放缓冲\t\t\t\tRenderTexture.ReleaseTemporary(buffer0);\t\t\t\tbuffer0 = buffer1;\t\t\t\tbuffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);\t\t\t\t// Render the horizontal pass\t\t\t\tGraphics.Blit(buffer0, buffer1, material, 1);\t\t\t\tRenderTexture.ReleaseTemporary(buffer0);\t\t\t\tbuffer0 = buffer1;\t\t\t}\t\t\tGraphics.Blit(buffer0, dest);\t\t\tRenderTexture.ReleaseTemporary(buffer0);\t\t} else {\t\t\tGraphics.Blit(src, dest);\t\t}\t}}Properties {\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\t\t_BlurSize (\"Blur Size\", Float) = 1.0\t}\tSubShader {\t\tCGINCLUDE\t\t#include \"UnityCG.cginc\"\t\tsampler2D _MainTex;\t\thalf4 _MainTex_TexelSize;\t\tfloat _BlurSize;\t\tstruct v2f {\t\t\tfloat4 pos : SV_POSITION;\t\t\thalf2 uv[5]: TEXCOORD0;\t\t};\t\tv2f vertBlurVertical(appdata_img v) {\t\t\tv2f o;\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\thalf2 uv = v.texcoord;\t\t\to.uv[0] = uv;\t\t\t//偏移后的uv\t\t\to.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;\t\t\to.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;\t\t\to.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;\t\t\to.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;\t\t\treturn o;\t\t}\t\tv2f vertBlurHorizontal(appdata_img v) {\t\t\tv2f o;\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\thalf2 uv = v.texcoord;\t\t\to.uv[0] = uv;\t\t\to.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;\t\t\to.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize;\t\t\to.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;\t\t\to.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize;\t\t\treturn o;\t\t}\t\tfixed4 fragBlur(v2f i) : SV_Target {\t\t\tfloat weight[3] = {0.4026, 0.2442, 0.0545};\t\t\tfixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];\t\t\tfor (int it = 1; it &lt; 3; it++) {\t\t\t\tsum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it];\t\t\t\tsum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it];\t\t\t}\t\t\treturn fixed4(sum, 1.0);\t\t}\t\tENDCG\t\tZTest Always Cull Off ZWrite Off\t\tPass {\t\t\tNAME \"GAUSSIAN_BLUR_VERTICAL\"\t\t\tCGPROGRAM\t\t\t#pragma vertex vertBlurVertical\t\t\t#pragma fragment fragBlur\t\t\tENDCG\t\t}\t\tPass {\t\t\tNAME \"GAUSSIAN_BLUR_HORIZONTAL\"\t\t\tCGPROGRAM\t\t\t#pragma vertex vertBlurHorizontal\t\t\t#pragma fragment fragBlur\t\t\tENDCG\t\t}\t}\tFallBack \"Diffuse\"调整屏幕亮度，饱和度，对比度基本概念不清楚屏幕亮度，饱和度，对比度的定义,这里参考了 csdn 博客，大家可以直接参考 @feilong_csdn【数字图像处理系列二】基本概念：亮度、对比度、饱和度、锐化、分辨率实现屏幕后处理效果基类using UnityEngine;using System.Collections;[ExecuteInEditMode][RequireComponent (typeof(Camera))]public class PostEffectsBase : MonoBehaviour {\t// Called when start\tprotected void CheckResources() {\t\tbool isSupported = CheckSupport();\t\tif (isSupported == false) {\t\t\tNotSupported();\t\t}\t}\t// Called in CheckResources to check support on this platform\tprotected bool CheckSupport() {\t\tif (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) {\t\t\tDebug.LogWarning(\"This platform does not support image effects or render textures.\");\t\t\treturn false;\t\t}\t\treturn true;\t}\t// Called when the platform doesn't support this effect\tprotected void NotSupported() {\t\tenabled = false;\t}\tprotected void Start() {\t\tCheckResources();\t}\t// 创建material 这里如果不传入material 将会创建一个material 的实例\tprotected Material CheckShaderAndCreateMaterial(Shader shader, Material material) {\t\tif (shader == null) {\t\t\treturn null;\t\t}\t\tif (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)\t\t\treturn material;\t\tif (!shader.isSupported) {\t\t\treturn null;\t\t}\t\telse {\t\t\tmaterial = new Material(shader);\t\t\tmaterial.hideFlags = HideFlags.DontSave;\t\t\tif (material)\t\t\t{\t\t\t\t//返回创建的material\t\t\t\treturn material;\t\t\t}\t\t\telse\t\t\t\treturn null;\t\t}\t}}亮度，对比度，饱和度的实现using UnityEngine;using System.Collections;public class BrightnessSaturationAndContrast : PostEffectsBase {\tpublic Shader briSatConShader;\t//可以省略Properties中的属性声明，Properties中声明的属性仅仅为了显示在材质面板中\t//对于屏幕特效来说，材质都是临时创建的，这些参数我们会从脚本中直接传递\tprivate Material briSatConMaterial;\tpublic Material material {\t\tget {\t\t\tbriSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);\t\t\treturn briSatConMaterial;\t\t}\t}\t[Range(0.0f, 3.0f)]\tpublic float brightness = 1.0f;\t[Range(0.0f, 3.0f)]\tpublic float saturation = 1.0f;\t[Range(0.0f, 3.0f)]\tpublic float contrast = 1.0f;\t//渲染图像时，检查材质是否可用\tvoid OnRenderImage(RenderTexture src, RenderTexture dest) {\t\tif (material != null) {\t\t\tmaterial.SetFloat(\"_Brightness\", brightness);\t\t\tmaterial.SetFloat(\"_Saturation\", saturation);\t\t\tmaterial.SetFloat(\"_Contrast\", contrast);\t\t\t//Graphics.Blit 将把第一个参数传递给名为_MainTex的属性，因此必须声明一个_MainTex的纹理属性。\t\t\tGraphics.Blit(src, dest, material);\t\t} else {\t\t\tGraphics.Blit(src, dest);\t\t}\t}}Properties {\t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {}\t\t_Brightness (\"Brightness\", Float) = 1\t\t_Saturation(\"Saturation\", Float) = 1\t\t_Contrast(\"Contrast\", Float) = 1\t}\tSubShader {\t\tPass {\t\t\tZTest Always Cull Off ZWrite Off\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"UnityCG.cginc\"\t\t\tsampler2D _MainTex;\t\t\thalf _Brightness;\t\t\thalf _Saturation;\t\t\thalf _Contrast;\t\t\t// struct appdata_img\t\t\t// {\t\t\t// \tfloat4 vertex : POSITION;\t\t\t// \thalf2 texcoord : TEXCOORD0;\t\t\t// \tUNITY_VERTEX_INPUT_INSTANCE_ID\t\t\t// };\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\thalf2 uv: TEXCOORD0;\t\t\t};\t\t\tv2f vert(appdata_img v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\to.uv = v.texcoord;\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t\tfixed4 renderTex = tex2D(_MainTex, i.uv);\t\t\t\t// Apply brightness\t\t\t\tfixed3 finalColor = renderTex.rgb * _Brightness;\t\t\t\t// Apply saturation\t\t\t\t//计算亮度值 通过对每个颜色分量乘以一个特定的系数再相加得到当前像素亮度值\t\t\t\tfixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;\t\t\t\t//饱和度为0的颜色值，使用_Saturation对上一步得到的颜色之间进行插值，从而得到希望的饱和度颜色\t\t\t\tfixed3 luminanceColor = fixed3(luminance, luminance, luminance);\t\t\t\tfinalColor = lerp(luminanceColor, finalColor, _Saturation);\t\t\t\t// Apply contrast\t\t\t\tfixed3 avgColor = fixed3(0.5, 0.5, 0.5);\t\t\t\t//对比度\t\t\t\tfinalColor = lerp(avgColor, finalColor, _Contrast);\t\t\t\treturn fixed4(finalColor, renderTex.a);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallback Off" }, { "title": "shader入门基础-内置变量，标签，函数，光照模型", "url": "/posts/shader22/", "categories": "unity", "tags": "shader", "date": "2020-05-12 10:36:00 +0800", "snippet": "变量Unity 内置的变换矩阵函数光照模型漫反射公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\)$\\vec n$ 是表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色，$c_{light}$ 是光源颜...", "content": "变量Unity 内置的变换矩阵函数光照模型漫反射公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\)$\\vec n$ 是表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色，$c_{light}$ 是光源颜色。高光反射phong 模型公式$$\\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec v\\cdot\\vec r)^{m{gloss}}\\[$m_{gloss}$是材质的光泽度（gloss）,也被称为反光度（shininess）,它用于控制高光区域的亮点有多大，$m_{gloss}$越大，亮点越小。$m_{specular}$是材质高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}$则是光源的颜色和强度。$\\vec r$是反射方向，反射可以通过计算获得 $\\vec r=2(\\vec n\\cdot\\vec l)\\vec n-\\vec l$#### Blinn模型公式\\]\\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec n\\cdot\\vec h)^{m{gloss}}\\(Blinn 基本思想是 避免计算反射方向$\\vec r$,引入新的矢量 $\\vec h$。\\)\\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}$$半兰伯特模型公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(\\alpha(0,\\vec n \\cdot \\vec l)+\\beta)\\)半兰伯特模型没有使用max操作来防止$\\vec n$和$\\vec l$和的点积为负值，而是进行了$\\alpha$倍的缩放和再加上一个$\\beta$的偏移。在绝大多数情况下，$\\alpha$和$\\beta$的值均为0.5。一般公式为\\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(0.5(0,\\vec n \\cdot \\vec l)+0.5)\\)指令常见的渲染状态设置选项 状态名称 设置指令 解释 Cull Cull Back Front Off 设置剔除模式:剔除背面/正面/关闭 ZTest ZTest Less Greater/LEqula/GEqual/Equal/NotEqual/Always 设置深度测试 ZWrite ZWrite On/Off 开启/关闭深度写入 Blend Blend SrcFactor DstFactor 开启并设置混合模式 用于SubShader则会对所有Pass生效，用于特定Pass则对特定Pass生效。透明度混合TagsSubShader的标签类型Pass的标签类型Unity提前定影的5个渲染队列$$" }, { "title": "shader入门基础-动画", "url": "/posts/shader21/", "categories": "unity", "tags": "shader", "date": "2020-05-12 10:36:00 +0800", "snippet": "Unity 内置时间变量 名称 类型 描述 _Time float4 t 是自然该场景加载开始所经过的时间，(t/20,t,2t,3t) _SinTime float4 t 是时间的正弦值，(t/8,t/4,t/2,t) _C...", "content": "Unity 内置时间变量 名称 类型 描述 _Time float4 t 是自然该场景加载开始所经过的时间，(t/20,t,2t,3t) _SinTime float4 t 是时间的正弦值，(t/8,t/4,t/2,t) _CosTime float4 t 是时间的余弦值，(t/8,t/4,t/2,t) unity_DeltaTime float4 dt 是时间增量，(dt,1/dt,smoothDt,1/smoothDt) 纹理动画Shader \"Practice/SequenceAnim\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _RowCount(\"行数\",int)=4 _ColCount(\"列数\",int)=4 _Speed(\"播放速度\",Range(0,100))=1.0 } SubShader { // No culling or depth Tags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"true\" \"RenderType\"=\"Transparent\"} Pass { Tags {\"LightModel\"=\"ForwardBase\"} Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _Speed; half _RowCount; half _ColCount; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv,_MainTex) ; return o; } fixed4 frag (v2f i) : SV_Target { float length = _Speed*_Time.y; half curRow = floor(length/_ColCount); half curCol = floor(length-curRow*_ColCount); half2 uv =float2(i.uv.x/_ColCount,i.uv.y/_RowCount); uv.x+= curCol/_ColCount; uv.y-= curRow/_RowCount; fixed4 col =tex2D(_MainTex,uv); return col; } ENDCG } }}滚动的背景Shader \"Practice/BgAnim\"{ Properties { _FirstBG (\"FirstBG\", 2D) = \"white\" {} _SecondBG (\"FirstBG\", 2D) = \"white\" {} _ScrollX(\"_ScrollX\",float) = 1 _ScrollX2(\"_ScrollX2\",float)=1.1 } SubShader { // No culling or depth Cull Off ZWrite Off ZTest Always Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _FirstBG; sampler2D _SecondBG; fixed4 _FirstBG_ST; fixed4 _SecondBG_ST; float _ScrollX2; float _ScrollX; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float4 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv.xy =TRANSFORM_TEX(v.uv,_FirstBG); o.uv.zw = TRANSFORM_TEX(v.uv,_SecondBG); return o; } fixed4 frag (v2f i) : SV_Target { float2 uv_offset = frac(float2(_ScrollX,0.0)*_Time.y); float2 uv_offset2 = frac(float2(_ScrollX2,0.0)*_Time.y); fixed4 col = tex2D(_FirstBG, i.uv.xy+uv_offset); fixed4 col2 =tex2D(_SecondBG,i.uv.zw+uv_offset2); fixed4 final_col=lerp(col,col2,col2.a); return final_col; } ENDCG } }}顶点动画DisableBatching: 批处理会合并所有相关的模型，而这些模型各自的模型空间会丢失。我们需要在物体的模型空间下对顶点位置进行偏移，因此需要取消批处理操作。Properties {\t\t_MainTex (\"Main Tex\", 2D) = \"white\" {}\t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1)\t\t_Magnitude (\"Distortion Magnitude\", Float) = 1 \t\t_Frequency (\"Distortion Frequency\", Float) = 1 \t\t_InvWaveLength (\"Distortion Inverse Wave Length\", Float) = 10 \t\t_Speed (\"Speed\", Float) = 0.5\t}\tSubShader {\t\t// Need to disable batching because of the vertex animation\t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"DisableBatching\"=\"True\"}\t\tPass {\t\t\tTags { \"LightMode\"=\"ForwardBase\" }\t\t\tZWrite Off\t\t\tBlend SrcAlpha OneMinusSrcAlpha\t\t\tCull Off\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"UnityCG.cginc\"\t\t\tsampler2D _MainTex;\t\t\tfloat4 _MainTex_ST;\t\t\tfixed4 _Color;\t\t\tfloat _Magnitude;\t\t\tfloat _Frequency;\t\t\tfloat _InvWaveLength;\t\t\tfloat _Speed;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat4 texcoord : TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat2 uv : TEXCOORD0;\t\t\t};\t\t\tv2f vert(a2v v) {\t\t\t\tv2f o;\t\t\t\tfloat4 offset;\t\t\t\toffset.yzw = float3(0.0, 0.0, 0.0);\t\t\t\toffset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex + offset);\t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _MainTex);\t\t\t\to.uv += float2(0.0, _Time.y * _Speed);\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t\tfixed4 c = tex2D(_MainTex, i.uv);\t\t\t\tc.rgb *= _Color.rgb;\t\t\t\treturn c;\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Transparent/VertexLit\"广告牌技术根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对摄像机。广告牌技术的本质是构建旋转矩阵。为了避免使用模型空间的中心作为锚点，我们可以利用顶点颜色存储每个顶点到锚点的距离值。Shader \"Practice/BillBoard\"{ Properties {\t\t_MainTex (\"Main Tex\", 2D) = \"white\" {}\t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1)\t\t_VerticalBillboarding (\"Vertical Restraints\", Range(0, 1)) = 1\t}\tSubShader {\t\t// 关闭批处理，批处理会导致模型各自的模型空间丢失\t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"DisableBatching\"=\"True\"}\t\tPass {\t\t\tTags { \"LightMode\"=\"ForwardBase\" }\t\t\tZWrite Off\t\t\tBlend SrcAlpha OneMinusSrcAlpha //关闭剔除让广告牌每个面都能显示\t\t\tCull Off\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"Lighting.cginc\"\t\t\tsampler2D _MainTex;\t\t\tfloat4 _MainTex_ST;\t\t\tfixed4 _Color;\t\t\tfixed _VerticalBillboarding;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat4 texcoord : TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat2 uv : TEXCOORD0;\t\t\t};\t\t\tv2f vert (a2v v) {\t\t\t\tv2f o;\t\t\t\t//模型空间位置原点\t\t\t\tfloat3 center = float3(0, 0, 0); //将摄像机位置转换到模型空间坐标\t\t\t\tfloat3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));\t\t\t\t// 摄像机指向原点的方向作为法线方向\t\t\t\tfloat3 normalDir = viewer - center; //_VerticalBillboarding == 1 我们使用摄像机指向原点的方向作为法线方向 //_VerticalBillboarding == 0 则固定方向作为法线方向\t\t\t\tnormalDir.y =normalDir.y * _VerticalBillboarding;\t\t\t\tnormalDir = normalize(normalDir);\t\t\t\t// 获取up方向\t\t\t\tfloat3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0); //叉积后获取指向右方的向量\t\t\t\tfloat3 rightDir = normalize(cross(upDir, normalDir));\t\t\t\tupDir = normalize(cross(normalDir, rightDir));\t\t\t\t// 使用3个正焦急矢量做相对于锚点旋转\t\t\t\tfloat3 centerOffs = v.vertex.xyz - center;\t\t\t\tfloat3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;\t\t\t\to.pos = UnityObjectToClipPos(float4(localPos, 1));\t\t\t\to.uv = TRANSFORM_TEX(v.texcoord,_MainTex);\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag (v2f i) : SV_Target {\t\t\t\tfixed4 c = tex2D (_MainTex, i.uv);\t\t\t\tc.rgb *= _Color.rgb;\t\t\t\treturn c;\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Transparent/VertexLit\"}对包含顶点动画的物体添加阴影\t\tPass { //阴影投射pass\t\t\tTags { \"LightMode\" = \"ShadowCaster\" }\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#pragma multi_compile_shadowcaster\t\t\t#include \"UnityCG.cginc\"\t\t\tfloat _Magnitude;\t\t\tfloat _Frequency;\t\t\tfloat _InvWaveLength;\t\t\tfloat _Speed;\t\t\tstruct v2f {\t\t\t V2F_SHADOW_CASTER;\t\t\t};\t\t\tv2f vert(appdata_base v) {\t\t\t\tv2f o;\t\t\t\tfloat4 offset;\t\t\t\toffset.yzw = float3(0.0, 0.0, 0.0);\t\t\t\toffset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;\t\t\t\tv.vertex = v.vertex + offset;\t\t\t\tTRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t SHADOW_CASTER_FRAGMENT(i)\t\t\t}\t\t\tENDCG\t\t}" }, { "title": "shader入门基础-复杂光照二", "url": "/posts/shader20/", "categories": "unity", "tags": "shader", "date": "2020-05-08 15:36:00 +0800", "snippet": "光照衰减Unity 使用一张纹理作为查找表来在片原着色器中计算逐像素光照的衰减。优点 计算衰减不依赖数学公式的复杂性，只需要使用一个参数做纹理采样。缺点 需要预处理得到采样纹理，而且纹理的大小也会影响到衰减的精度。 不直观，不方便，一旦把数据存储到查找表中，无法使用其他数学公式计算衰减。用于光照衰减的纹理Unity 在内部使用了一张名为_LightTexture0 的纹理来计算光照衰减...", "content": "光照衰减Unity 使用一张纹理作为查找表来在片原着色器中计算逐像素光照的衰减。优点 计算衰减不依赖数学公式的复杂性，只需要使用一个参数做纹理采样。缺点 需要预处理得到采样纹理，而且纹理的大小也会影响到衰减的精度。 不直观，不方便，一旦把数据存储到查找表中，无法使用其他数学公式计算衰减。用于光照衰减的纹理Unity 在内部使用了一张名为_LightTexture0 的纹理来计算光照衰减，如果对该光源使用了 cookie，则对应_LightTextureB0,通常我们只关心_LightTexture0 对角线上的纹理颜色值，（0，0）表示与光源重合位置的衰减值，（1，1）点表明了光源空间中所关心距离最远的点的衰减。顶点在光源空间中的坐标，参数是顶点在世界空间中的坐标。 float3 lightCoord=mul(_LightMatrix0,float4(i.worldPosition,1)).xyz fixed atten = tex2D(_LightTexture0,dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL阴影实时渲染中，最常使用的是一种名为 Shadow Map 的技术。把摄像机的位置放在光源重合位置上，阴影便是摄像机看不到的地方，在前向渲染中，如果场景中最重要的平行光开启了阴影，Unity 就会为该光源计算它的阴影映射纹理（shadowmap），shandowmap 本质是一张深度图，记录了该光源的位置出发能看到场景中距离它最近的表面位置（深度信息）。Unity 会将 LightModel 设置为 ShadowCaster 的 Pass 专门用来更新光源的阴影映射纹理。让物体投射阴影 Pass { Name \"ShadowCaster\" Tags { \"LightMode\" = \"ShadowCaster\" }CGPROGRAM#pragma vertex vert#pragma fragment frag#pragma target 2.0#pragma multi_compile_shadowcaster#pragma multi_compile_instancing // allow instanced shadow pass for most of the shaders#include \"UnityCG.cginc\"struct v2f { V2F_SHADOW_CASTER; UNITY_VERTEX_OUTPUT_STEREO};v2f vert( appdata_base v ){ v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o;}float4 frag( v2f i ) : SV_Target{ SHADOW_CASTER_FRAGMENT(i)}ENDCG让物体接收阴影Cast Shadows 设置为 On,该物体就会加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。Recieve Shadows则可以选择是否让物体接受来自其他物体的阴影。SHADOW_COORDS 在顶点着色器的输出结构体 v2f 中添加，该宏用于声明一个用于对阴影纹理采样的坐标。该宏的参数需要是下一个可用的插值寄存器的索引值。TRANSFER_SHADOW 在顶点着色器返回之前添加，用于在顶点着色器中计算上一步中声明的阴影纹理坐标。SHADOW_ATTENUATION 在片元着色器中计算阴影值。UNITY_LIGHT_ATTENUATION 该宏用于计算光照衰减和阴影的宏， 第一个参数 atten，宏会声明，我们不需要声明，第二个参数是结构体 v2f，第三个参数是世界空间的坐标。//传递shadow coordinatesfixed shadow = SHADOW_ATTENUATION(i)注意这些宏中会使用上下文变量来进行相关计算，例如 TRANSFER_SHADOW 会使用 v.vertex 或 a.pos 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名匹配。我们需要保证 a2v 结构体的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体必 a2v 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。对于使用了透明度测试的物体，要得到正确的阴影效果，我们会把 Fallback 设置为 Transparent/Cutout/VertexLit。实践// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'Shader \"Practice/AlphaTest\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _Cutoff(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader归入到提“TransparentCutout” //\"IgnoreProjector\"=\"True\" 不受投影器影响 //渲染序列设置为 AlphaTest Tags { \"Queue\"=\"AlphaTest\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"TransparentCutout\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" #include \"AutoLight.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; //下一个插值寄存器 3 SHADOW_COORDS(3) }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _Cutoff; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; TRANSFER_SHADOW(o); return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); clip(texColor.a-_Cutoff); //equal to //if(m_diffuse.a-_Cutoff)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //计算光照衰减和阴影 UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos); //环境光和漫反射光 col = fixed4(ambient+c_diffuse*atten,1.0); return col; } ENDCG } } FallBack \"Transparent/Cutout/VertexLit\"}" }, { "title": "shader入门基础-高级纹理", "url": "/posts/shader19/", "categories": "unity", "tags": "shader", "date": "2020-05-07 16:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解立方体纹理(Cubemap)立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面，立方体纹理的名称也由此而来。立方体纹理是环境映射(Environment Mapping)的一种实现方法。天空盒 shader 使用 Skybox/6 Sided,需要 6 张纹理 纹理的 wrap...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解立方体纹理(Cubemap)立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面，立方体纹理的名称也由此而来。立方体纹理是环境映射(Environment Mapping)的一种实现方法。天空盒 shader 使用 Skybox/6 Sided,需要 6 张纹理 纹理的 wrap mode 设置为 Clamp，以防止在接缝处出现不匹配的现象 保证渲染场景的摄像机的 Camera 组件 Clear Flags 被设置为 Skybox天空盒设置如图反射//反射Shader \"Practice/Reflection\" {\tProperties {\t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1)\t\t_ReflectColor (\"Reflection Color\", Color) = (1, 1, 1, 1)\t\t_ReflectAmount (\"Reflect Amount\", Range(0, 1)) = 1\t\t//立方体纹理进行采样\t\t_Cubemap (\"Reflection Cubemap\", Cube) = \"_Skybox\" {}\t}\tSubShader {\t\tTags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"}\t\tPass {\t\t\tTags { \"LightMode\"=\"ForwardBase\" }\t\t\tCGPROGRAM\t\t\t#pragma multi_compile_fwdbase\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"Lighting.cginc\"\t\t\t#include \"AutoLight.cginc\"\t\t\tfixed4 _Color;\t\t\tfixed4 _ReflectColor;\t\t\tfixed _ReflectAmount;\t\t\tsamplerCUBE _Cubemap;\t\t\tstruct a2v {\t\t\t\t//使用阴影计算的宏，必须用vertex\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t};\t\t\tstruct v2f {\t\t\t\t//使用阴影计算的宏，必须用pos\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat3 worldPos : TEXCOORD0;\t\t\t\tfixed3 worldNormal : TEXCOORD1;\t\t\t\tfixed3 worldViewDir : TEXCOORD2;\t\t\t\tfixed3 worldRefl : TEXCOORD3;\t\t\t\tSHADOW_COORDS(4)\t\t\t};\t\t\tv2f vert(a2v v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal);\t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\t\t\t\to.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);\t\t\t\t// 计算 反射方向\t\t\t\to.worldRefl = reflect(-o.worldViewDir, o.worldNormal);\t\t\t\tTRANSFER_SHADOW(o);\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t\tfixed3 worldNormal = normalize(i.worldNormal);\t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\t\t\t\tfixed3 worldViewDir = normalize(i.worldViewDir);\t\t\t\t//环境光\t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\t\t\t\t////C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式\t\t\t\tfixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));\t\t\t\t//texCUBE 对立方体纹理进行采样\t\t\t\tfixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;\t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\t\t\t\t// Mix the diffuse color with the reflected color\t\t\t\t//混合漫反射和反射颜色等价于\t\t\t\t//float lerp(float a, float b, float w) {\t\t\t\t//return a(1-w) + b * w;\t\t\t\t//}\t\t\t\t//混合后 阴影值与漫反射和反射颜色值相乘\t\t\t\tfixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;\t\t\t\treturn fixed4(color, 1.0);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Reflective/VertexLit\"}折射斯涅耳定律 \\(\\eta_1sin\\theta_1=\\eta_2sin\\theta_2\\) \\(\\eta_1和\\eta_2\\) 是兩個介質的折射率。refract 第一个参数是入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的，第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值。//折射Shader \"Practice/Refract\"{ Properties { _Color (\"Color Tint\", Color) = (1,1,1,1) _RefractColor(\"折射顏色\",Color)=(1,1,1,1) _RefractAmount(\"折射程度\",Range(0,1))=1 //入射光線所在介質的折射率和折射光線所在介質的折射率之間的比值 _RefractRatio(\"折射率比值\",Range(0.1,1))=0.5 //环境映射的立方体纹理 _Cubemap(\"环境映射\",Cube)=\"_Skybox\"{} } SubShader { // No culling or depth Tags{\"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { Tags{\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\"\t\t\t#include \"AutoLight.cginc\" fixed4 _Color;\t\t\tfixed4 _RefractColor;\t\t\tfloat _RefractAmount;\t\t\tfixed _RefractRatio;\t\t\tsamplerCUBE _Cubemap;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat3 worldPos : TEXCOORD0;\t\t\t\tfixed3 worldNormal : TEXCOORD1;\t\t\t\tfixed3 worldViewDir : TEXCOORD2;\t\t\t\tfixed3 worldRefr : TEXCOORD3;\t\t\t\tSHADOW_COORDS(4)\t\t\t};\t\t\tv2f vert(a2v v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal);\t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\t\t\t\to.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);\t\t\t\t//第一个参数是入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的，第三个参数是入射光线 //所在介质的折射率和折射光线所在介质的折射率之间的比值。\t\t\t\to.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);\t\t\t\tTRANSFER_SHADOW(o);\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t\tfixed3 worldNormal = normalize(i.worldNormal);\t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\t\t\t\tfixed3 worldViewDir = normalize(i.worldViewDir);\t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\t\t\t\tfixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));\t\t\t\t// Use the refract dir in world space to access the cubemap\t\t\t\tfixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;\t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);\t\t\t\t// Mix the diffuse color with the refract color\t\t\t\tfixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;\t\t\t\treturn fixed4(color, 1.0);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Reflective/VertexLit\"}菲涅尔反射菲涅尔反射描述了一种光学现象，即当光线照射到物体表面上是，一部分发生反射，一部分进入物体内部，发生折射或散射。菲涅尔近等式： \\(F_{schlick(\\vec v,\\vec n)} = F_0+(1-F_0)*(1-\\vec v \\cdot \\vec n)^5\\)渲染纹理渲染目标纹理(Render Target Texture,RTT) GPU 允许把整个三维场景渲染到一个中间缓冲中。多重渲染目标纹理(Multiple Render Target,MRT) GPU 允许我们把场景同事渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。这里实现渲染目标纹理，把摄像机的渲染结果输出到一张图片中//渲染目标物理Shader \"Practice/RTT\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} } SubShader { Tags {\"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag\t\t\t#include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; struct a2v { float4 vertex:POSITION; float3 texcoord:TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 pos : SV_POSITION; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); return col; } ENDCG } }}GrabPass一种特殊的 Pass 来获取屏幕图像的目的。通常使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单透明混合不同，使用GrabPass 可以让我们对该物体后面的图像进行更浮渣的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。Grab 支持的两种形式： 直接使用 GrabPass{}，然后在后续的 Pass 中直接使用_GrabTexture 来访问屏幕图像。但是，当场景中有多个物体都使用了这样的形式抓取屏幕是，这种方法的性能消耗比较大，因为对于每一个使用它的物体，Unity 都会为他单独进行一次昂贵的屏幕抓取操作。但这种方法可以让每个物体得到不同的屏幕图像，这取决于它们的渲染队列及渲染它们当时当前屏幕缓冲中的颜色。 使用 GrabPass{“TextureName”},Unity 只会在每一帧时为第一个使用名为 TextureName 的纹理的物体执行一次抓取屏幕的操作，而这个纹理同样可以在其他 Pass 中被访问。这种消耗更小。Shader \"Practice/GlassRefraction\" {\tProperties {\t\t//该玻璃材质纹理\t\t_MainTex (\"Main Tex\", 2D) = \"white\" {}\t\t//该玻璃法线纹理\t\t_BumpMap (\"Normal Map\", 2D) = \"bump\" {}\t\t//模拟反射所用的环境纹理\t\t_Cubemap (\"Environment Cubemap\", Cube) = \"_Skybox\" {}\t\t//用于控制模拟折射时图像的扭曲程度\t\t_Distortion (\"Distortion\", Range(0, 100)) = 10\t\t//用于控制折射程度，0则不会发生折射，只有反射，1则只有反射没有折射\t\t_RefractAmount (\"Refract Amount\", Range(0.0, 1.0)) = 1.0\t}\tSubShader {\t\t// 保证不透明物体先进行渲染.\t\tTags { \"Queue\"=\"Transparent\" \"RenderType\"=\"Opaque\" }\t\tGrabPass { \"_RefractionTex\" }\t\tPass {\t\t\tCGPROGRAM\t\t\t#pragma vertex vert\t\t\t#pragma fragment frag\t\t\t#include \"UnityCG.cginc\"\t\t\tsampler2D _MainTex;\t\t\tfloat4 _MainTex_ST;\t\t\tsampler2D _BumpMap;\t\t\tfloat4 _BumpMap_ST;\t\t\tsamplerCUBE _Cubemap;\t\t\tfloat _Distortion;\t\t\tfixed _RefractAmount;\t\t\t//GrabPass指定的纹理名称\t\t\tsampler2D _RefractionTex;\t\t\t//纹理纹素大小\t\t\tfloat4 _RefractionTex_TexelSize;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t\tfloat4 tangent : TANGENT;\t\t\t\tfloat2 texcoord: TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat4 scrPos : TEXCOORD0;\t\t\t\tfloat4 uv : TEXCOORD1;\t\t\t\tfloat4 TtoW0 : TEXCOORD2;\t\t\t float4 TtoW1 : TEXCOORD3;\t\t\t float4 TtoW2 : TEXCOORD4;\t\t\t};\t\t\tv2f vert (a2v v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\to.scrPos = ComputeGrabScreenPos(o.pos);\t\t\t\to.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);\t\t\t\to.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);\t\t\t\tfloat3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\t\t\t\tfixed3 worldNormal = UnityObjectToWorldNormal(v.normal);\t\t\t\tfixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);\t\t\t\tfixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;\t\t\t\to.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);\t\t\t\to.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);\t\t\t\to.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag (v2f i) : SV_Target {\t\t\t\tfloat3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);\t\t\t\tfixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));\t\t\t\t// Get the normal in tangent space\t\t\t\tfixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));\t\t\t\t// Compute the offset in tangent space\t\t\t\tfloat2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;\t\t\t\ti.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;\t\t\t\tfixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;\t\t\t\t// Convert the normal to world space\t\t\t\tbump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));\t\t\t\tfixed3 reflDir = reflect(-worldViewDir, bump);\t\t\t\tfixed4 texColor = tex2D(_MainTex, i.uv.xy);\t\t\t\tfixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;\t\t\t\tfixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;\t\t\t\treturn fixed4(finalColor, 1);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Diffuse\"}" }, { "title": "shader入门基础-更复杂光照", "url": "/posts/shader17/", "categories": "unity", "tags": "shader", "date": "2020-05-07 11:36:00 +0800", "snippet": "渲染路径 前向渲染路径(Forward Rendering Path) 延迟渲染路径(Defferred Rendering Path) 顶点照明渲染路径(Vertex Lit Rendering Path)通过设置 Pass 的 LightMode 标签实现 Pass{ Tags {\"LightMode\"=\"ForwardBase\"} }LightMode ...", "content": "渲染路径 前向渲染路径(Forward Rendering Path) 延迟渲染路径(Defferred Rendering Path) 顶点照明渲染路径(Vertex Lit Rendering Path)通过设置 Pass 的 LightMode 标签实现 Pass{ Tags {\"LightMode\"=\"ForwardBase\"} }LightMode 标签支持的渲染路径设置选项 标签名 描述 Always 不管使用哪种渲染路径，该 Pass 总是会被渲染，但不会计算任何光照 ForwardBase 用于前向渲染，该 pass 会计算环境光，最重要的平行光，逐顶点/SH 光源和 Lightmaps ForwardAdd 用于前向渲染，该 pass 会计算额外的逐像素光源，每个 pass 对应一个光源 Deferred 用于延迟渲染，该 pass 会渲染 G 缓冲 G-buffer ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 PrepassBase 用于遗留的延迟渲染，该 pass 会渲染法线和高光反射的指数部分 PrepassFinal 用于遗留的延迟渲染，该 pass 通过合并纹理、光照和自发光来渲染得到最后的颜色 Vertex、VertexLMRGBM 和 VertexLM 用于遗留的顶点照明渲染 前向渲染路径的原理Pass{ for (each primitive in this model){ for (each fragment covered by this primitive) { if (failed in depth test) { //如果没有通过深度测试，则该片元时不可见 discard; } else{ //如果片元可见就记性光照机选 float4 color = Shading(materialinfo,pos,normal,lightDir,viewDir); //更新帧缓冲 writeFrameBuffer(fragment,color); } } }}对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个 Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设场景中有个 N 个物体，每个物体受 M 个光源的影响，那么要渲染整个场景一共需要 N*M 个 pass。Unity 中的前向渲染前向渲染路径有 3 种光照处理方式： 逐顶点处理 逐像素处理 球谐函数（Spherical Harmonics,SH）unity 会根据场景中各个光源的设置以及这些光源对物体影响程度，对这些光源进行一个重要度排序。其中，一定数目光源按逐像素方式处理，最多 4 个光源会按逐顶点方式处理，剩下按 SH 方式处理。Unity 排序规则 场景中最亮的平行光总是按逐像素处理 渲染模式被设置成 Not Important 的光源，会按逐顶点或者 SH 处理。 渲染模式被设置成 Important 的光源，会按照逐像素处理。 如果根据以上规则得到的逐像素官员数量小于 Quality Setting 中的逐像素光源数量，会有更多的光源以逐像素的方式进项渲染。前向渲染的两种 Pass延迟渲染原理Pass 1 { //第一个pass不进行真正的光照计算 //仅仅把光照计算需要的信心存储到G缓冲中 for(each primitive in this model) { for(each fragment covered by this privitive) { if(failed in depth test) { //如果没有通过深度测试，说明该片元是不可见 discard; }else{ //如果该片元可见 //就把需要的信息存储到G缓冲中 writeGBuffer(materialInfo,pos,normal); } } }}Pass 2{ //利用G缓冲中的信息进行真正的光照计算 for(each pixel in the screen) { if(the pixel is valid) { //如果该像素是有效地 //读取它对应的G缓冲中的信息 readGBuffer(pixel,materialInfo,pos,normal); //根据读取到的信息进行光照计算 float4 color = Shading(materialInfo,pos,normal,lightDir,viewDir); //更新帧缓冲 writeFrameBuffer(pixel,color); } }}延迟渲染使用的 Pass 数目通常就是两个，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。Unity 中的延迟渲染延迟渲染路径适合场景中光源数量较多、使用前向渲染路径会造成性能瓶颈的情况下使用，延迟渲染中的每个光源都可以按逐像素的方式进行处理。延迟渲染缺点： 不支持真正的抗锯齿(anti-aliasing)功能 不能处理半透明物体（延迟渲染需要深度写入） 对显卡有一定要求Unity 中使用延迟渲染路径，需要提供两个 Pass。第一个 Pass 用于渲染 G 缓冲，在该 Pass 中将物体漫反射、高光反射、颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区，因此，延迟渲染路径的效率不依赖与场景是否复杂，而是屏幕的分辨率高低。对于每个物体来说，这个 Pass 仅会执行一次。第二个 Pass 用于计算真正的光照模型。这个 Pass 使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。默认的 G 缓冲区包括以下渲染纹理(Render Texture): RT0：ARGB，RGB 通道存储漫反射颜色，A 通道未使用 RT1：ARGB，RGB 通道存储高光反射颜色，A 通道存储高光反射的指数部分（Gloss） RT2：ARGB，RGB 通道存储法线，A 通道未使用 RT3：ARGB，存储自发光+lightmap+反射探针 深度缓冲和模板缓冲光源类型常用的光源属性有光源的位置，方向，颜色，强度，衰减。 平行光 没有位置，只有方向，不会衰减。 点光源 球形，球心处光照强度最强，球体边界处最弱，衰减值可以由一个函数定义。 聚光灯 锥形 面光源" }, { "title": "shader案例-LOGO 闪光", "url": "/posts/shader16/", "categories": "unity", "tags": "shader", "date": "2020-04-30 11:36:00 +0800", "snippet": "LOGO 闪光//Logo 闪光shaderShader \"Practice/FlashTestMat\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} //间隔 _Interval(\"Interval\",float) = 5.0 _BrightNess(\"Bright...", "content": "LOGO 闪光//Logo 闪光shaderShader \"Practice/FlashTestMat\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} //间隔 _Interval(\"Interval\",float) = 5.0 _BrightNess(\"BrightNess\",float)=10000000 _BrightWidth(\"BrightWidth\",Range(0,0.5))=0.1 } SubShader { // No culling or depth Cull Off ZWrite Off // Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _Interval; float _BrightNess; float _BrightWidth; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } //闪光 //可以在这里丰富闪光的形状，其他逻辑等 fixed4 blinn(float2 uv) { //当前时间段 fixed delta = fmod(_Time.y,_Interval); float dis =saturate(_BrightWidth- abs(uv.x+0.5-delta)); float cur_brightness=_BrightNess*dis; fixed3 rgb = fixed3(1,1,1)*cur_brightness; return fixed4(rgb,1); } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); //透明不闪光 clip(col.a-0.1); fixed4 brighness = blinn(i.uv); col = col+brighness; return col; } ENDCG } } Fallback \"UI/Default\"}增加调试参数为了策划方便调试，这里丰富下 shader 的参数，让光柱进行一定的偏移，给定闪光频率。//Logo 闪光shaderShader \"Practice/FlashTestMat\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} //冷却 _Cold(\"Cold\",Range(0,3.0)) = 1.0 //完成闪烁时间 _FinishTime(\"FinishTime\",Range(1.0,4.0))=2.0 //光亮度 _BrightNess(\"BrightNess\",float)=100 //光柱宽度 _BrightWidth(\"BrightWidth\",Range(0,0.5))=0.1 //偏移速率 _Rad(\"Rad\",Range(0,3.14))=1.0 //偏移弧度 } SubShader { // No culling or depth Cull Off ZWrite Off // Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _FinishTime; float _BrightNess; float _BrightWidth; float _Rad; float _Cold; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } //闪光 fixed4 blinn(float2 uv) { //当前时间段 fixed delta = _Time.y/(_FinishTime+_Cold); delta =delta - floor(delta); delta = delta*(_FinishTime+_Cold)/_FinishTime; //根据y轴做一定的偏移s fixed _offset_x=uv.y*tan(_Rad); float dis =saturate(_BrightWidth- abs(uv.x+0.5+_offset_x-delta)); float cur_brightness=_BrightNess*dis; fixed3 rgb = fixed3(1,1,1)*cur_brightness; return fixed4(rgb,1); } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); //透明不闪光 clip(col.a-0.1); fixed4 brighness = blinn(i.uv); col = col+brighness; return col; } ENDCG } } Fallback \"UI/Default\"}" }, { "title": "shader入门基础-透明效果四", "url": "/posts/shader15/", "categories": "unity", "tags": "shader", "date": "2020-04-30 10:36:00 +0800", "snippet": "开启深度写入的透明效果由于关闭深度写入可能造成错误排序解决方案:使用两个 pass 来渲染模型第一个 pass 开启深度写入，但不输出颜色，目的仅仅是把该模型深度值写入到深度缓冲中。第二个 pass 进行正常的透明度混合，由于上一个 pass 已经得到了逐像素的正确深度信息，该 pass 就可以额按照像素级别的深度排序结果进行透明渲染。缺点：多使用一个 pass 会对性能造成一定的影响。Co...", "content": "开启深度写入的透明效果由于关闭深度写入可能造成错误排序解决方案:使用两个 pass 来渲染模型第一个 pass 开启深度写入，但不输出颜色，目的仅仅是把该模型深度值写入到深度缓冲中。第二个 pass 进行正常的透明度混合，由于上一个 pass 已经得到了逐像素的正确深度信息，该 pass 就可以额按照像素级别的深度排序结果进行透明渲染。缺点：多使用一个 pass 会对性能造成一定的影响。ColorMask: ColorMask RGB |A|0| 其他任何 R,G,B,A 的组合，ColorMask 会指定渲染结果的输出通道，而不是通常的 RGBA 四个通道都被写入。可选参数为 RGBA 的任意组合以及 0，参数为 0 时，那么不会写入任何通道，但是会做一次深度测试，并将深度值写入深度缓冲区。这就是我们这个 pass 需要的，先做一次深度写入Shader \"Practice/AlphaBlendZWrite\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { ZWrite On // ColorMask 0 的时候不输出任何颜色通道，只会做一次深度测试，并写入到深度缓存中 ColorMask 0 } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } } Fallback \"Transparent/VertexLit\"}两个 pass，解决排序后的效果图双面渲染的透明效果Culll Cull Back|Front|Off 可以声依永 Cull 指令来控制需要剔除哪个面的渲染图元，默认设置为 Back ，那么那些背对着摄像机的渲染图元就不会被渲染，设置 Front，朝向摄像机的渲染图元不会被渲染，设置 off 会关闭剔除功能，所有图元都会被渲染，这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，例如这里的双面渲染的透明效果，通常情况下课不会关闭剔除功能。透明度测试的双面渲染只需要在 Pass 的渲染设置中使用 Cull 指令来关闭剔除即可。 Pass { Tags{\"LightModel\"=\"ForwardBase\"} Cull Off }透明度混合的双面渲染由于透明度混合会关闭深度写入，想要得到正确的透明效果，渲染顺序是非常重要的，我们需要保证图元从后往前渲染。为此我们选择把双面渲染的工作分成两个 pass，第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，Unity 会顺序执行 SubShader 中的各个 Pass，因此背面总是在正面之前渲染。这里偷懒了，直接在原来的 shader 中复制，粘贴Shader \"Practice/AlphaBlendZWrite\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //第一个Pass只渲染背面，剔除前面 Cull Front //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //第二个Pass只渲染前面，剔除背面 Cull Back //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } } Fallback \"Transparent/VertexLit\"}" }, { "title": "shader入门基础-透明效果三", "url": "/posts/shader14/", "categories": "unity", "tags": "shader", "date": "2020-04-29 14:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解透明度混合这种方法可以得到真正的半透明效果，它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色进行混合，得到新的颜色。但是透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。混合就和两个操作数有关 源颜色(source color), 目标颜色(destination co...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解透明度混合这种方法可以得到真正的半透明效果，它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色进行混合，得到新的颜色。但是透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。混合就和两个操作数有关 源颜色(source color), 目标颜色(destination color)。源颜色 用 S 表示，指由片元着色器产生的颜色值；目标颜色 D,指的从颜色缓冲中读取到的颜色值。对他们进行混合后得到的输出颜色，用 O表示，它会重新写入到颜色缓冲中。当我们使用 Blend 命令时，混合会自动开启。shaderLab 中设置混合因子的命令 命令 描述 Blend SrcFactor DstFactor \\(\\mathtt O_{rgb}=SrcFatcor*\\mathtt S_{rgb}+DstFactor*\\mathtt D_{rgb})\\) Blend SrcFactor DstFactor,SrcFactorA DstFactorA \\(\\mathtt O_{rgb}=SrcFatcor*\\mathtt S_{rgb}+DstFactor*\\mathtt D_{rgb})\\quad \\mathtt O_a = SrcFactorA* \\mathtt S_a+DstFactorA*\\mathtt D_a\\) 透明度混合实践Shader \"Practice/AlphaBlend\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } }}效果如图//Blend srcAlpha OneMinusSrcAlpha屏蔽 Blend 命令，可以发现半透明效果消失了。只有使用 Blend 命令打开混合后，这里透明度才会对片元透明效果有任何影响。" }, { "title": "shader入门基础-透明效果二", "url": "/posts/shader13/", "categories": "unity", "tags": "shader", "date": "2020-04-29 11:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解clip 函数在片原着色器中使用 clip 函数进行透明度测试，clip 参数可以是标量，也可以是矢量。如果给定的参数的任何一个分量是负数，就会舍弃当前像素输出的颜色。discard 指令显示剔除片元。void clip(float 4){ if (any(x&lt;0)) dis...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解clip 函数在片原着色器中使用 clip 函数进行透明度测试，clip 参数可以是标量，也可以是矢量。如果给定的参数的任何一个分量是负数，就会舍弃当前像素输出的颜色。discard 指令显示剔除片元。void clip(float 4){ if (any(x&lt;0)) discard;}透明度测试实践Shader \"Practice/AlphaTest\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _Cutoff(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader归入到提“TransparentCutout” //\"IgnoreProjector\"=\"True\" 不受投影器影响 //渲染序列设置为 AlphaTest Tags { \"Queue\"=\"AlphaTest\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"TransparentCutout\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _Cutoff; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); clip(texColor.a-_Cutoff); //equal to //if(m_diffuse.a-_Cutoff)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 col = fixed4(ambient+c_diffuse,1.0); return col; } ENDCG } }}效果图" }, { "title": "shader入门基础-透明效果一", "url": "/posts/shader12/", "categories": "unity", "tags": "shader", "date": "2020-04-28 17:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解透明度测试(Alpha Test)当片元的透明度小于某个阈值时，对应片元就会被舍弃，被舍弃的片元不会再进行任何处理，不会对颜色缓冲产生任何影响，当片元透明度大于等于这个阈值的时候，就会按照普通不透明的物体处理方式来处理，进行深度测试，深度写入等。透明度测试无法得到真正的半透明效果。透明度混合(Alph...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解透明度测试(Alpha Test)当片元的透明度小于某个阈值时，对应片元就会被舍弃，被舍弃的片元不会再进行任何处理，不会对颜色缓冲产生任何影响，当片元透明度大于等于这个阈值的时候，就会按照普通不透明的物体处理方式来处理，进行深度测试，深度写入等。透明度测试无法得到真正的半透明效果。透明度混合(Alpha Blend)使用当前片元的透明度作为混合银子，与已经存储在颜色缓冲中的颜色进行混合，得到新的颜色。但是透明度混合需要关闭深度写入，关闭深度写入破坏了深度缓冲的工作机制，因此渲染渲染顺序将会变得非常重要。透明度混合只关闭了深度写入，没有关闭深度测试，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。对于透明度混合来说，深度缓冲时只读的。深度缓冲(depth buffer,z-buffer)深度缓冲记录颜色缓冲区中相对应像素点在 3D 世界中距离摄像机的远近，通过深度缓冲，我们可以进行深度测试，从而确定遮挡关系。有了深度缓冲后，渲染顺序就不那么重要了，可以根据深度渲染物体。上面提及的透明度混合的时候会关闭深度写入，因此关闭深度写入时，渲染顺序会确定物体渲染的先后顺序，关闭后，渲染顺序会变得非常重要。深度测试(ZTest) 深度写入(ZWrite)如果开启了看深度测试，GPU 会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。如果该片元通过了深度测试，开发者可以指定是否用这个片元的深度值覆盖掉原有的深度值，这个是通过开启/关闭深度写入来做到。这里回顾之前渲染流水线的知识，可以加深理解，这部分的操作都在渲染流水线的逐片元操作中。通过流程图可以理解，这部分的工作流程和再流水线中的作用。逐片元在流水线最后，这里会合并输出。逐片元操作深度写入和深度测试工作流程图混合流程工作流程图渲染顺序的排序渲染引擎一般会对物体进行顺序。 先渲染所有不透明物体，并开启它们的深度测试和深度写入。 把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。渲染队列Unity 为了解决渲染顺序问提供了渲染队列（render queue），用 SubShader 的 Queue 标签决定我们模型将归于哪个渲染队列。透明度测试SubShader{\tTags{\"Queue\"=\"AlphaTest\"}\tPass{\t}}透明度混合SubShader{\tTags{\"Queue\"=\"Transparent\"}\tPass{\t\tZwrite Off\t}}" }, { "title": "shader入门基础-渐变纹理，遮罩纹理", "url": "/posts/shader11/", "categories": "unity", "tags": "shader", "date": "2020-04-27 17:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解渐变纹理学习如何使用渐变纹理来控制漫反射光照。Shader \"Practice/RampTex\"{ Properties { _RampTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) =(1...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解渐变纹理学习如何使用渐变纹理来控制漫反射光照。Shader \"Practice/RampTex\"{ Properties { _RampTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) =(1,1,1,1) _Specular (\"Specular\", Color) = (1, 1, 1, 1)\t\t_Gloss (\"Gloss\", Range(8.0, 256)) = 20 } SubShader { Tags { \"LightModel\"=\"Forward\" } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color;\t\t\tsampler2D _RampTex;\t\t\tfloat4 _RampTex_ST;\t\t\tfixed4 _Specular;\t\t\tfloat _Gloss;\t\t\tstruct a2v {\t\t\t\tfloat4 vertex : POSITION;\t\t\t\tfloat3 normal : NORMAL;\t\t\t\tfloat4 texcoord : TEXCOORD0;\t\t\t};\t\t\tstruct v2f {\t\t\t\tfloat4 pos : SV_POSITION;\t\t\t\tfloat3 worldNormal : TEXCOORD0;\t\t\t\tfloat3 worldPos : TEXCOORD1;\t\t\t\tfloat2 uv : TEXCOORD2;\t\t\t};\t\t\tv2f vert(a2v v) {\t\t\t\tv2f o;\t\t\t\to.pos = UnityObjectToClipPos(v.vertex);\t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal); //把法线方向从模型空间转换到世界空间中\t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;//把顶点坐标从模型空间转换到世界空间中\t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _RampTex);//把材质纹理映射到uv坐标上\t\t\t\treturn o;\t\t\t}\t\t\tfixed4 frag(v2f i) : SV_Target {\t\t\t\tfixed3 worldNormal = normalize(i.worldNormal);\t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));\t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; //使用halfLambert 构建一个一维纹理坐标，并用这个纹理坐标对渐变纹理_RampTex进行采样 //因为_RampTex实际就是一个一维纹理，它在纵轴方向上颜色不变，因此u,v都采用了halfLambert\t\t\t\tfixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;\t\t\t\tfixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;\t\t\t\tfixed3 diffuse = _LightColor0.rgb * diffuseColor;\t\t\t\tfixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));\t\t\t\tfixed3 halfDir = normalize(worldLightDir + viewDir);\t\t\t\tfixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);\t\t\t\treturn fixed4(ambient + diffuse + specular, 1.0);\t\t\t}\t\t\tENDCG\t\t}\t}\tFallBack \"Specular\"}遮罩纹理遮罩允许我们可以保护某些区域，使他们免于某些修改。使用遮罩纹理流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个通道的值来与某种表面属性进行相乘，这样，当该通道值为 0 时，可以保护表面不收该属性的影响。使用遮罩纹理可以让美术人员可以更加精准的控制模型表面的各种性质。Shader \"Practice/MaskTex\"{ Properties{ _Color(\"Color Tint\",Color)=(1,1,1,1) _MainTex(\"MainTex\",2D)=\"white\"{} _BumpMap(\"BumpMap\",2D)=\"bump\"{} //法线贴图 _BumpScale(\"Bump Scale\",float)=1 //高光反射遮罩纹理 _SpecularMask(\"Specular Mask\",2D)=\"white\" {} //遮罩影响程度 _SpecularScale (\"Specular Scale\",float)=1.0 //高光颜色 _Specular(\"Specular\",Color)=(1,1,1,1) //光泽度，光点大小 _Gloss(\"Gloss\",float)=1.0 } SubShader{ Pass{ //前向渲染 Tags {\"LightModel\" = \"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" //对应Properties 类型和名字匹配的变量 fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; sampler2D _SpecularMask; float4 _SpecularMask_ST; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex:POSITION; //法线向量是float3 float3 normal:NORMAL; //切线由于需要w分量确定副切线方向，所以切线虽然是向量，但是也需要用float4 float4 tangent:TANGENT; //模型第一组纹理坐标 float4 texcoord:TEXCOORD0; }; struct v2f { float4 uv:TEXCOORD0; //视角方向 float3 viewDir:TEXCOORD1; //光照方向 float3 lightDir:TEXCOORD2; //顶点 float4 pos:SV_POSITION; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy= v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; TANGENT_SPACE_ROTATION; //获取到光照方向，转换到切线坐标空间 o.lightDir =mul(rotation,ObjSpaceLightDir(v.vertex)).xyz; //获取到视角方向，从模型空间转换到切线空间 o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz; return o; } fixed4 frag(v2f i):SV_TARGET { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); //像素反映射到法线 fixed3 tangentNormal =UnpackNormal(tex2D(_BumpMap,i.uv)); // tangentNormal.xy*=_BumpScale; tangentNormal.z = sqrt(1.0-saturate(dot(tangentNormal.xy,tangentNormal.xy))); fixed3 albedo =tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir+tangentViewDir); fixed specularMask = tex2D(_SpecularMask,i.uv).r*_SpecularScale; fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss)*specularMask; return fixed4(ambient+diffuse+specular,1.0); } ENDCG } }}有遮罩无高光遮罩这里我们使用 r 分量计算掩码之，用得到的掩码值和_SpecularScale 相乘，r=0 的地方将不会受高光影响。" }, { "title": "shader入门基础-凹凸映射", "url": "/posts/shader10/", "categories": "unity", "tags": "shader", "date": "2020-04-27 15:36:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解凹凸映射使用一张纹理来修改模型表面的法线，为模型提供更多细节。使用法线纹理进行凹凸映射法线方向的分量范围在[-1,1],像素分量范围为[0,1],法线到像素的映射 $pixel = \\frac{normal+1}{2}$.我们在 shader 中对法线纹理采样后，需要进行反映射 $normal=pix...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解凹凸映射使用一张纹理来修改模型表面的法线，为模型提供更多细节。使用法线纹理进行凹凸映射法线方向的分量范围在[-1,1],像素分量范围为[0,1],法线到像素的映射 $pixel = \\frac{normal+1}{2}$.我们在 shader 中对法线纹理采样后，需要进行反映射 $normal=pixel\\ast 2-1$。模型空间的法线纹理(object-space normal map)定义：模型空间中的表面法线存储在一张纹理中。优点： 实现简单，直观。 纹理坐标缝合处和尖锐的边角部分，课件突变较少，可以提供平滑的边界。切线空间的法线纹理(tangent-space normal map)定义: 模型定点的切线空间来存储法线，对于模型的每个定点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而 z 轴是顶点的法线方向（n）,x 轴是顶点的切线方向（t）,而 y 轴可由法线和切线叉积而得，也被称为副切线。优点: 自由度高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型。切线空间下的纹理记录的是相对法线信息，意味着，把纹理应用到完全不同的网格上，也可以得到合理结果。 可进行 UV 动画。我们可以移动一个纹理的 UV 坐标来实现凹凸移动的效果，但使用模型空间下的法线纹理得到完全错误的结果。这种 UV 动画在水或者火山熔岩。 可以重用法线纹理。 可压缩。在切线空间下计算光照模型实现：在片元着色器中通过纹理采样得到切线空间的法线，然后在于切线空间下的视角方向，光照方向等进行计算。需要在顶点着色器中把视角方向，光照方向从来模型空间变换到切线空间中。即我们需要知道的从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，在顶点着色器中按切线（x 轴），副切线（y 轴），法线（z 轴）的顺序按列排列。在 UnityCG.cginc 中定义了 TANGENT_SPACE_ROTATION实现_BumpMap,使用”bump”作为它的默认值。”bump”是 Unity 内置法线纹理，当没有提供任何法线纹理时，bump 对应模型自带法线信息。_BmupScale 控制凹凸程度，0 则意味该法线纹理不会对光照产生任何影响。tangent.w 分量决定切线空间中的第三个坐标轴-副切线的方向性。法线纹理中存储的是把法线经过映射后得到的像素值，因此需要把他们反映射出来。Shader \"Practice/NormalMapTagSpace\"{ Properties { _Color(\"Color Tint\",Color) = (1,1,1,1)// 漫反射颜色 _MainTex (\"Main Tex\", 2D) = \"white\" {}//贴图 _BumpMap(\"Bump Map\",2D) = \"bump\" {}//法线贴图 _BumpScale(\"Bump Scale\",float) = 1.0//凹凸程度 _Specular(\"Specular\",Color)= (1,1,1,1)//高光颜色 _Gloss(\"Gloss\",Range(8,256)) = 20 //光泽度 } SubShader { Pass{ Tags { \"LightModel\" = \"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; sampler2D _BumpMap;//法线纹理 float4 _MainTex_ST; float4 _BumpMap_ST;//法线纹理属性 fixed4 _Specular; float _Gloss; float _BumpScale;//凹凸程度 struct a2v{ float4 vertex:POSITION; //模型顶点信息 float3 normal:NORMAL;//法线 float4 tangent:TANGENT;//切线 float4 texcoord:TEXCOORD0;//纹理 }; struct v2f { float4 pos:SV_POSITION; float4 uv:TEXCOORD0;//纹理映射坐标 float3 lightDir:TEXCOORD1;//光线 float3 viewDir:TEXCOORD2;//视线 }; v2f vert(a2v i){ v2f o; o.pos = UnityObjectToClipPos(i.vertex); //减少插值寄存器的 xy存储_MainTex的纹理坐标 ，zw存储_BumpMap坐标 o.uv.xy =i.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; o.uv.zw = i.texcoord.xy*_BumpMap_ST.xy+_BumpMap_ST.zw; //计算副切线 float3 binormal = cross(normalize(i.normal),normalize(i.tangent.xyz))*i.tangent.w; float3x3 rotation = float3x3(i.tangent.xyz,binormal,i.normal); //获取到顶点坐标的光线防线后，把光线方向从模型空间转换到切线空间 o.lightDir = mul(rotation,ObjSpaceLightDir(i.vertex)).xyz; o.lightDir = mul(rotation,ObjSpaceViewDir(i.vertex)).xyz; return o; } fixed4 frag(v2f i):SV_TARGET { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); fixed3 tangentNormal; tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0-saturate(dot(tangentNormal,tangentViewDir))); fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir+tangentViewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } Fallback \"Diffuse\"}切线空间下计算的 凹凸映射" }, { "title": "shader入门基础-基础纹理", "url": "/posts/shader9/", "categories": "unity", "tags": "shader", "date": "2020-04-27 14:10:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解光照模型实践,使用单张纹理代替漫反射颜色高光公式\\[\\mathtt{c}_{specular}=(\\mathtt{c}_{light}\\cdot\\mathtt{m}_{specular})max(0,\\vec n\\cdot\\vec h)^{m_{gloss}} \\qquad\\vec h=\\frac{\\...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解光照模型实践,使用单张纹理代替漫反射颜色高光公式\\[\\mathtt{c}_{specular}=(\\mathtt{c}_{light}\\cdot\\mathtt{m}_{specular})max(0,\\vec n\\cdot\\vec h)^{m_{gloss}} \\qquad\\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}\\]漫反射公式\\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\)根据公式 我们需要取到$\\vec n$ 表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色,$m_{specular}$ 材质高光颜色，$c_{light}$ 是光源颜色_MainTex_ST:在 Unity 中，我们需要使用纹理名_ST 的方式来声明某个纹理的属性。其中 ST 是缩放(scale)和平移(translation)的缩写。_MainTex_ST 可以让我们得到该纹理的缩放和平移值，_MainTex_ST.xy 存储的是缩放值，而_MainTex_ST.zw 存储的是偏移值。在顶点着色器中，我们使用纹理的属性值_MainTex_ST 来对顶点的纹理坐标进行变换，得到最终的纹理。在 UnityCG.cginc 中有预定义#define TRANSFORM_TEX(tex,name) (tex.xy*name##_ST.xy+name##_ST.zw)。Shader \"Practice/SingleTex\"{ Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color)= (1,1,1,1) //漫反射颜色 _Gloss(\"Gloss\",Range(8.0,256)) = 20 //光泽度,光泽度越高反光面积越大 _Specular(\"Specular\",Color) = (1,1,1,1) //高光颜色 } SubShader { Tags { \"LightMode\"=\"ForwardBase\" } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" #include \"Lighting.cginc\" struct appdata { float4 vertex : POSITION; float4 normal : NORMAL; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; half _Gloss; fixed4 _Specular; fixed4 _Color; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //转换到裁剪空间 o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;//转换到世界空间 o.uv = _MainTex_ST.xy*v.texcoord.xy+_MainTex_ST.zw; // ==&gt; o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); 等价于上面的转换 return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col; //C_diffuse = (C_light·M_diffuse)max(0,N·L) fixed3 worldNormal = normalize(i.worldNormal); //归一化后的世界坐标 fixed3 wolrdLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); //光线 fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; //取样当前纹理映射坐标的颜色 * 漫反射颜色 &lt;==&gt; 反射的颜色 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; //环境光*反射光 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 这里m_diffuse用的是纹理颜色 fixed3 diffuse = _LightColor0.rgb*albedo*saturate(dot(worldNormal,wolrdLightDir)); //WolrdSpaceViewDir 输入的是模型空间中顶点 fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));//输入的是世界空间的顶点坐标 //H=(V+L)/|V+L| fixed3 halfDir = normalize(wolrdLightDir+viewDir); //C_specular = (C_light*m_specular)pow(max(0,N·H),m_gloss) fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(saturate(dot(worldNormal,halfDir)),_Gloss); col = fixed4(ambient+diffuse+specular,1.0); return col; } ENDCG } }}使用单张纹理效果图" }, { "title": "shader入门基础-光照模型总结", "url": "/posts/shader8/", "categories": "unity", "tags": "shader", "date": "2020-04-27 10:10:00 +0800", "snippet": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解，为了表示方便，与书中公式略有差别。漫反射漫反射光照符合 兰伯特定律：反射光线强度与法线表面和光源方向的夹角的余弦值成正比。公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdo...", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解，为了表示方便，与书中公式略有差别。漫反射漫反射光照符合 兰伯特定律：反射光线强度与法线表面和光源方向的夹角的余弦值成正比。公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\)$\\vec n$ 是表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色，$c_{light}$ 是光源颜色。高光反射phong 模型这里的高光反射是经验模型，并不完全符合真实世界的高光反射现象，它可用于计算沿完全镜面反射方向被反射的光线，这可以让物体看起来有光泽。公式$$\\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec v\\cdot\\vec r)^{m{gloss}}\\[$m_{gloss}$是材质的光泽度（gloss）,也被称为反光度（shininess）,它用于控制高光区域的亮点有多大，$m_{gloss}$越大，亮点越小。$m_{specular}$是材质高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}$则是光源的颜色和强度。$\\vec r$是反射方向，反射可以通过计算获得 $\\vec r=2(\\vec n\\cdot\\vec l)\\vec n-\\vec l$#### Blinn模型公式\\]\\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec n\\cdot\\vec h)^{m{gloss}}\\(Blinn 基本思想是 避免计算反射方向$\\vec r$,引入新的矢量 $\\vec h$。\\)\\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}$$半兰伯特模型公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(\\alpha(0,\\vec n \\cdot \\vec l)+\\beta)\\)半兰伯特模型没有使用max操作来防止$\\vec n$和$\\vec l$和的点积为负值，而是进行了$\\alpha$倍的缩放和再加上一个$\\beta$的偏移。在绝大多数情况下，$\\alpha$和$\\beta$的值均为0.5。一般公式为\\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(0.5(0,\\vec n \\cdot \\vec l)+0.5)\\)逐像素与逐顶点根据计算在不同函数中的实现，可以分为逐像素光照和逐顶点光照。在片元着色器。由于顶点数目往往小于像素数目，因此逐顶点光照的计算量往往小于逐像素光照。但是由于逐顶点光照依赖线性插值来得到像素光照，因此光照模型中有非线性的计算时，逐顶点光照会有问题。由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部颜色总是暗语顶点最高颜色值。$$" }, { "title": "NGUILabel走马灯", "url": "/posts/NGUILabel/", "categories": "unity", "tags": "NGUI", "date": "2020-02-14 00:00:00 +0800", "snippet": " content需求在项目接近尾声的时候，由于本地化的差异，导致很多 ui 超过了显示框，这时候运营方提出需要在部分地方加上滚动，当文字超过显示的框的时候，自动滚动。由于项目已经接近尾声，所以务必改动要小。在不改变 UI 结构，以及方便策划快速更改的情况下，开发的组件。实现设置如图using System;using System.Collections;using System.Coll...", "content": " content需求在项目接近尾声的时候，由于本地化的差异，导致很多 ui 超过了显示框，这时候运营方提出需要在部分地方加上滚动，当文字超过显示的框的时候，自动滚动。由于项目已经接近尾声，所以务必改动要小。在不改变 UI 结构，以及方便策划快速更改的情况下，开发的组件。实现设置如图using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 文字走马灯效果/// &lt;/summary&gt;[RequireComponent(typeof(UIPanel))][RequireComponent(typeof(UILabel))]public class ScrollLabelNew : MonoBehaviour{ private UIPanel panel; private UILabel label; Vector2 panel_offset; private Vector3 start_pos; public float speedx; public float offset; float mtime; public float stop_time; private void Awake() { panel = GetComponent&lt;UIPanel&gt;(); label = GetComponent&lt;UILabel&gt;(); panel_offset = panel.clipOffset; start_pos = label.transform.localPosition; } private void OnEnable() { int max_depth = 0; foreach (UIPanel panel in transform.GetComponentsInParent&lt;UIPanel&gt;()) { if (panel.depth &gt; max_depth) { max_depth = panel.depth; } } panel.depth = max_depth+1; } private void Update() { if (panel == null || label == null) { return; } if (speedx &lt; 0) { if (label.worldCorners[3].x &lt; panel.worldCorners[3].x+offset) { if (mtime &gt; 0) { mtime = mtime - Time.deltaTime; return; } mtime = stop_time; label.transform.localPosition = start_pos; panel.clipOffset = panel_offset; } } else { if (label.worldCorners[3].x &gt; panel.worldCorners[3].x+offset) { if (mtime &gt; 0) { mtime = mtime - Time.deltaTime; return; } mtime = stop_time; label.transform.localPosition = start_pos; panel.clipOffset = panel_offset; } } label.transform.localPosition += new Vector3(speedx * Time.deltaTime, 0, 0); panel.clipOffset+=new Vector2(-speedx * Time.deltaTime, 0); }}效果" }, { "title": "shader入门基础知识七", "url": "/posts/shader7/", "categories": "unity", "tags": "shader", "date": "2020-01-29 00:00:00 +0800", "snippet": " contentcg 流程控制与循环在前面的章节中shader 入门基础知识五提到过，cg 不支持switch ，break,default,goto 等关键字，这里不再尝试，下面对 if else 和 for while 进行尝试。如图，我们对于模型坐标小于 0 的地方给与红色，大于 0 的地方给与绿色，得到的是渐变从红到绿的颜色。原因是片元着色器的输入是对着色器输出插值后的结果，因此结...", "content": " contentcg 流程控制与循环在前面的章节中shader 入门基础知识五提到过，cg 不支持switch ，break,default,goto 等关键字，这里不再尝试，下面对 if else 和 for while 进行尝试。如图，我们对于模型坐标小于 0 的地方给与红色，大于 0 的地方给与绿色，得到的是渐变从红到绿的颜色。原因是片元着色器的输入是对着色器输出插值后的结果，因此结果是渐变的。如图，count=30 的时候我们把颜色赋值成红色，否则绿色，显示红色则说明前面的循环都得到了有效的执行。这里前面提过 cg 支持 bool，和相关的运算符，三目运算符也是支持的。" }, { "title": "shader入门基础知识六", "url": "/posts/shader6/", "categories": "unity", "tags": "shader", "date": "2020-01-28 00:00:00 +0800", "snippet": " contentCg 入门三 swizzle 操作通过 swizzle 操作，可以将 float2，或者 float2 的分量重新组成其他的 float3，float4。这个时候 float2 的 x,y 分别是 1，0 新组成的 float4 则是（1，0,0,1）因此是红色。可以同时使用分量，顺序也是可以打乱的。这里我们使用 float2 的分量，并且 y 在前，x 在后，所以新的 f...", "content": " contentCg 入门三 swizzle 操作通过 swizzle 操作，可以将 float2，或者 float2 的分量重新组成其他的 float3，float4。这个时候 float2 的 x,y 分别是 1，0 新组成的 float4 则是（1，0,0,1）因此是红色。可以同时使用分量，顺序也是可以打乱的。这里我们使用 float2 的分量，并且 y 在前，x 在后，所以新的 float4是（0，1，0，0），因此是绿色的。对于 swizzle 操作，向量的分量可以是 xyzw，也可以是 rgba，但是在一次操作中是不允许使用 xyzw 和 rgba 的。swizzle 操作也允许相同的分量多次使用，例如全部取 x。这时候对应的 float4 的值是（1,1,0,1）红色+绿色是黄色，因此如图我们获取到的是黄色。在矩阵中我们不能直接使用 xyzw，但是通过下标我们可以获取到对应的向量，这时候是可以使用 swizzle 操作的，如图我们使用的全是 x，因此对应的向量值是（1,1,1,1）是白色。如上图，数组也是不可以使用分量而是需要通过下标获取的。" }, { "title": "shader入门基础知识五", "url": "/posts/shader5/", "categories": "unity", "tags": "shader", "date": "2020-01-26 00:00:00 +0800", "snippet": " contentCg 入门二 C 语言和 Cg 语言的区别联系前言这里主要是我个人的理解，大家想要准确的解释，还是建议大家上 nvdia 官网读官方文档Similar Operations That Must be Expressed DifferentlyThere are several changes that force the same operation to be expre...", "content": " contentCg 入门二 C 语言和 Cg 语言的区别联系前言这里主要是我个人的理解，大家想要准确的解释，还是建议大家上 nvdia 官网读官方文档Similar Operations That Must be Expressed DifferentlyThere are several changes that force the same operation to be expresseddifferently in Cg than in C: //cg 和 c 都有，但是表达却不同的地方 A Boolean type, bool, is introduced, with corresponding implications foroperators and control constructs.//c 语言中的 bool 类型是非 0 为真，cg 中有 true false Arrays are first‐class types because Cg does not support pointers.//数组是第一等类型，因为 cg 不支持指针 ，这里强调数组相当于基础数据类型，不支持引用传递而是值传递 Functions pass values by value/result, and thus use an out or inoutmodifier in the formal parameter list to return a parameter. By default,formal parameters are in, but it is acceptable to specify this explicitly.Parameters can also be specified as in out, which is semantically thesame as inout.//函数传参通过值传递，因此通过 inout 修饰符返回形参列表中的一个修饰符Differences from ANSI CCg was developed based on the ANSI‐C language with the following majoradditions, deletions, and changes. (This is a summary—more detail isprovided later in this document)://基于 c 语言的添加删除更改 Language profiles (described in “Profiles” on page 225) may subsetlanguage capabilities in a variety of ways. In particular, language profilesmay restrict the use of for and while loops. For example, some profilesmay only support loops that can be fully unrolled at compile time. A binding semantic may be associated with a structure tag, a variable, or astructure element to denote that object’s mapping to a specific hardwareor API resource. See “Binding Semantics” on page 242.  Reserved keywords goto, break, and continue are not supported. Reserved keywords switch, case, and default are not supported. Labels are not supported either.//保留的关键词，goto,break,continue,switch，case，default 不被支持，Labels 也是不被支持的 Pointers and pointer‐related capabilities (such as the &amp; and -&gt; operators)are not supported.//不支持指针和指针相关,例如 &amp; 和 -&gt; Arrays are supported, but with some limitations on size anddimensionality. Restrictions on the use of computed subscripts are alsopermitted. Arrays may be designated as packed. The operations allowedon packed arrays may be different from those allowed on unpackedarrays. Predefined packed types are provided for vectors and matrices. Itis strongly recommended these predefined types be used.//支持数组，但是有指针和维度的限制 Unsized arrays can be created by declaring an array’s dimension as [].The array’s actual dimension can be set at runtime before a finalcompilation step.//可以通过将数组的维度声明为[]来创建无大小的数组。数组的实际维度可以在运行时在 final 之前设置 There is a built‐in swizzle operator: .xyzw or .rgba for vectors. Thisoperator allows the components of a vector to be rearranged and alsoreplicated. It also allows the creation of a vector from a scalar.//内置的 swizzle 操作符:.xyzw 或.rgba 用于向量。swizzle 运算符允许向量的分量也可以重新排列复制。它还允许从标量创建向量 For an lvalue, the swizzle operator allows components of a vector ormatrix to be selectively written. There is a similar built‐in swizzle operator for matrices:This operator allows access to individual matrix components and allowsthe creation of a vector from elements of a matrix. For compatibility withDirectX 8 notation, there is a second form of matrix swizzle, which isdescribed later. Numeric data types are different. Cg’s primary numeric data types arefloat, half, and fixed. Fragment profiles are required to support allthree data types, but may choose to implement half and fixed at floatprecision. Vertex profiles are required to support half and float, butmay choose to implement half at float precision. Vertex profiles mayomit support for fixed operations, but must still support definition offixed variables. Cg allows profiles to omit run‐time support for int. Cgallows profiles to treat double as float.  Many operators support per‐element vector operations. The ?:, ||, &amp;&amp;, !, and comparison operators can be used with bool four‐vectors to perform four conditional operations simultaneously. The sideeffects of all operands to the ?:, ||, and &amp;&amp; operators are alwaysexecuted.//Cg 主要数据类型 fixed,half,float,支持?:（三目运算符）||(或)，&amp;&amp;(且)，!(非)等布尔操作符 Non‐static global variables and parameters to top‐level functions—suchas main()—may be designated as uniform. A uniform variable may beread and written within a program, just like any other variable.However, the uniform modifier indicates that the initial value of thevariable or parameter is expected to be constant across a large number ofinvocations of the program. A new set of sampler* types represents handles to texture objects. //sampler 处理采样对象 Functions may have default values for their parameters, as in C++. Thesedefaults are expressed using assignment syntax.//函数可能会有默认参数，这些默认的参数使用赋值语义表示 Function overloading is supported.//支持方法重写 There is no enum or union. //不支持枚举或者联合体  Bit‐field declarations in structures are not allowed. There are no bit‐field declarations in structures.//不支持位域 Variables may be defined anywhere before they are used, rather than justat the beginning of a scope as in C. (That is, we adopt the C++ rules thatgovern where variable declarations are allowed.) Variables may not beredeclared within the same scope.// 变量可以声明在使用前的任何地方，不可以重复声明在相同的代码块 Vector constructors, such as the form float4(1,2,3,4), may be usedanywhere in an expression.//向量构造器可以在任何表达的地方使用 A struct definition automatically performs a corresponding typedef,as in C++.//结构体自动执行位相应的类型 An interface can be specified to define a set of methods that comprisesan abstract interface.//接口可以指定定义一些方法来组成抽象接口 A struct type can be declared as implementing an interface byadding a colon “:” and the name of the interface after the name of thestruct.//一个结构体可以通过：实现一个接口  Methods can be defined in the body of a struct definition.//方法可以定义在结构体内部 C++‐style // comments are allowed in addition to C‐style /…/comments.//注释风格支持 // 和/…/" }, { "title": "shader入门基础知识四", "url": "/posts/shader4/", "categories": "unity", "tags": "shader", "date": "2020-01-19 00:00:00 +0800", "snippet": " contentCg 入门Cg 关键字 in,out,inout in:修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。 out:修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果； inout:修辞一个形参既用于输入也用于输出，这是典型的引用传递。 out是可以被 return 代替...", "content": " contentCg 入门Cg 关键字 in,out,inout in:修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。 out:修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果； inout:修辞一个形参既用于输入也用于输出，这是典型的引用传递。 out是可以被 return 代替的创建 shader创建如图所示 shader,并且创建一个材质，游戏中创建一个 cube，将材质赋给 cube，将得到如下所示的颜色颜色解释NDC 是一个长宽高取值范围为[-1,1]的立方体,因此 obj_pos 的分量取值范围也是[-1,1]颜色取值范围是[0,1],小于 0 的取 0，因此获得下图所示的颜色shader debug 时用到的假彩色图像技术也是类似如此，通过将数据映射到[0,1]范围作为颜色输出到屏幕上，然后通过屏幕颜色来判断数据是否正确。" }, { "title": "shader入门基础知识三", "url": "/posts/shader3/", "categories": "unity", "tags": "shader", "date": "2020-01-18 00:00:00 +0800", "snippet": " content常用的语义，Cg 中的变量，后续还会有其他的补充完成第一个实例后 shader 入门基础知识二，一些我们之前还不是很清楚的地方需要扩展。Cg 代码中与 Properties 关联前文提过需要使用 Properties 中的代码，需要在 Cg 代码块中声明类型和名称都匹配的变量，这里完善shader 入门基础知识二中的表格，方便之后使用 属性类型 ...", "content": " content常用的语义，Cg 中的变量，后续还会有其他的补充完成第一个实例后 shader 入门基础知识二，一些我们之前还不是很清楚的地方需要扩展。Cg 代码中与 Properties 关联前文提过需要使用 Properties 中的代码，需要在 Cg 代码块中声明类型和名称都匹配的变量，这里完善shader 入门基础知识二中的表格，方便之后使用 属性类型 例子 Cg 变量类型 Int _Int(“Int”,Int)=2 float Float _Float(“Float”,Float)=2 float,half,fixed Range _Range(“Range”,Range(1.0,3.0))=2.0 float,half,fixed Color _Color(“Color”,Color)=(1.0,1.0,1.0,1.0) float4,half4,fixed4 Vector _Vector(“Vector”,Vector)=(1.0,1.0,1.0,1.0)) float4,half4,fixed4 2D _2D(“2D”,2D)=””{} sampler2D Cube _Cube(“Cube”,Cube)=”white”{} samplerCube 3D _3D(“3D”,3D)=”white”{} sampler3D float：32 位高精度浮点数。 half：16 位中精度浮点数。范围是[-60000, +60000] fixed：11 位低精度浮点数。范围是[-2.0, 2.0]根据使用情形，尽量使用低精度的数据类型。例如采样颜色的时候使用 fixed 类型。顶点着色器输入结构体中常用语义，模型输出到 shader 的数据 语义 描述 NORMAL 顶点法线，通常是 float3 类型 POSITION 模型空间中的顶点位置，通常是 float4 类型 TANGENT 顶点切线，通常是 float4 类型 TEXCOORDn 模型纹理坐标，TEXCOORD0 表示第一组坐标纹理，依次类推，通常是 float2,float4 类型，ShaderModel4 一下版本最多支持 8 个纹理，4 和以上支持 16 个 COLOR 顶点颜色，通常是 fixed4 或 float4 类型 顶点着色器输出结构体中常用语义，并且片元着色器的输入 语义 描述 SV_POSITION 裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。否则将无法得到裁剪空间中的顶点坐标，也就无法把顶点渲染到屏幕上 COLOR0 输出第一组顶点颜色 COLOR1 输出第二组顶点颜色 TEXCOORDn 通常用于输出纹理坐标，不是必须 片元着色器输出时常用语义 语义 描述 SV_Target 输出值将会储存到渲染目标（render target）中 为了让 Shader 能在所有平台下正常工作，需尽可能使用如下语义描述 Shader 的输入输出变量SV_POSITION：顶点着色器输出的顶点位置SV_Target：片元着色器的输出颜色SV 即 system value" }, { "title": "shader入门基础知识二", "url": "/posts/shader2/", "categories": "unity", "tags": "shader", "date": "2020-01-15 00:00:00 +0800", "snippet": " content创建我们第一个着色器着色器模板 Standard Surface Shader标准表面着色器，模拟现实材质与灯光的关系，书写逻辑更符合普通程序 Unilt Shader不受光照影响的模板 Shader ,常用于 UI，特效 Image Effect Shader屏幕后处理定制模板 shader，常见的 Bloom,模糊等效果 Compute Shader运行在图形显...", "content": " content创建我们第一个着色器着色器模板 Standard Surface Shader标准表面着色器，模拟现实材质与灯光的关系，书写逻辑更符合普通程序 Unilt Shader不受光照影响的模板 Shader ,常用于 UI，特效 Image Effect Shader屏幕后处理定制模板 shader，常见的 Bloom,模糊等效果 Compute Shader运行在图形显卡上的一段程序，可以直接将 GPU 作为并行处理器，从而使 GPU 不仅具有 3D 渲染能力，还具有其他的运算能力编写属性这里我们先创建一个 Unilt Shader,并且删除 SubShader 的内容，只保留 Properties。其中Properties 语义包含了一些属性，通过这些属性，我们可以方便的调整材质属性，并且在 shader 中访问这些属性。Properties语义块的定义如下 Properties { _MainTex (\"Texture\", 2D) = \"white\" {} }属性名字_MainTex,通常以下划线开始，材质面板现实的名字”Texture”,2D 是当前属性的指定类型， “white” {}是默认值。那么 shader 中都有哪些属性呢 属性类型 例子 Int _Int(“Int”,Int)=2 Float _Float(“Float”,Float)=2 Range _Range(“Range”,Range(1.0,3.0))=2.0 Color _Color(“Color”,Color)=(1.0,1.0,1.0,1.0) Vector _Vector(“Vector”,Vector)=(1.0,1.0,1.0,1.0)) 2D _2D(“2D”,2D)=””{} Cube _Cube(“Cube”,Cube)=”white”{} 3D _3D(“3D”,3D)=”white”{} 其中 2D,Cube 3D 3 种是纹理类型，了解这些后可以声明一个只有 Properties 的 shader，并在里面声明纹理和颜色属性,创建一个材质命名 HelloMat,将我们创建的 shader，赋值给材质球，我们来看看效果。对应的材质球显示这里我们在材质球中看到了声明的_Texture 属性和_Color 属性,那么我们如何再着色器中访问这些属性呢,更改这些属性并最后反应到材质，模型上呢接下来完善刚才的 shader,添加如下代码。编写完成后我们将得到如下效果的材质球小结到这里我们完成了我们的第一个 shader，这个例子了解了如何在 cg 代码中引用 Properties 的变量，了解了顶点着色器和片元着色器，以及变量如何再顶点着色器和片元着色器中传递，如何获取模型的数据，最后片元着色器如何输出等。在下一篇文章中会总结下 Properties 和 cg 变量的对应，常见的语义等。" }, { "title": "shader入门基础知识一", "url": "/posts/shader1/", "categories": "unity", "tags": "shader", "date": "2020-01-14 00:00:00 +0800", "snippet": " content开始编写着色器前我们需要了解的一些基础知识 什么是渲染管线gpu 内部处理图形信号相互独立的并行单元，一个渲染管线（流水线）是一序列可以并行和按照固定顺序进行的阶段。 Shader通用的 shader 是渲染流水线的某些特定阶段，例如顶点着色器阶段(vertex shader)和片元着色器阶段(fragment shader)TODO 渲染流水线 UnityShade...", "content": " content开始编写着色器前我们需要了解的一些基础知识 什么是渲染管线gpu 内部处理图形信号相互独立的并行单元，一个渲染管线（流水线）是一序列可以并行和按照固定顺序进行的阶段。 Shader通用的 shader 是渲染流水线的某些特定阶段，例如顶点着色器阶段(vertex shader)和片元着色器阶段(fragment shader)TODO 渲染流水线 UnityShaderUnity 为开发者提供的高层级的渲染抽象层，而所有 UnityShader 都是有 ShaderLab 编写的，ShaderLab 是 unity 提供的编写 Unity Shader 的一种说明性语言，使用 ShaderLab 后开发者将不需要和许多文件和设置打交道 着色器语言 ShadingLaguage DirectX 的 HLSL（High Level Shading Language） OpenGL 的 GLSL (OpenGL Shading Language) NVIDIA Cg (C for Graphic) 选择哪种语言呢？首先 GLSL 是跨平台的，但是 GLSL 得跨平台是由于 OpenGL 没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作，因此 GLSL 是依赖硬件而非操作系统的，对于不同的硬件，编译结果会不一致。对于手游或者端游开发，我们依赖的是操作系统级的，而非硬件。HLSL 是微软控制着色器编译，对于不同硬件，相同编译器编译结果是相同的CG 根据平台不同，会编译成相应的中间语言，而 cg 是和微软合作的产物，因此语法和 HLSL 相像在 Unity 中我们可以认为是等价的，因此后续我们使用”Cg/HLSL”来编写我们的着色器 什么是 DirectX,OpenGLDirectX,OpenGL 是图像应用层的编程接口，这些接口用于渲染二维或者三维图像 什么是 DrawCall，为什么 DrawCall 多了会导致帧率下降DrawCall cpu 调用图像编程接口，以命令 Gpu 进行渲染的操作 eg. DirextX 中的 DrawIndexedPrimitive。每次调用 DrawCall 前，cpu 需要向 GPU 发送很多内容，包括数据，状态，命令等，在这一阶段 cpu 需要完成很多工作，例如检查渲染状态等。完成后 gpu 开始渲染，gpu 渲染能力很强，渲染 200 或者 2000 个三角网格通常花费差不多，真正造成帧率下降的原因是 cpu 在 DrawCall 过多之后，会花费大量时间在准备上述工作和提交 DrawCall 上。" } ]

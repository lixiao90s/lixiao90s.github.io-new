<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="图" /><meta name="author" content="晓" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。" /><meta property="og:description" content="1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。" /><link rel="canonical" href="https://lixiao90s.github.io/posts/datastructure10/" /><meta property="og:url" content="https://lixiao90s.github.io/posts/datastructure10/" /><meta property="og:site_name" content="晓的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-02T14:16:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="图" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@晓" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"晓"},"dateModified":"2020-07-02T14:16:00+08:00","datePublished":"2020-07-02T14:16:00+08:00","description":"1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。","headline":"图","mainEntityOfPage":{"@type":"WebPage","@id":"https://lixiao90s.github.io/posts/datastructure10/"},"url":"https://lixiao90s.github.io/posts/datastructure10/"}</script><title>图 | 晓的博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="晓的博客"><meta name="application-name" content="晓的博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/zh.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/sample/favicon.ico" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">晓的博客</a><p class="site-subtitle fst-italic mb-0">学习&工作记录</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>关于</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/lixiao90s" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">首页</a> </span> <span>图</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="false"><header><h1 data-toc-skip>图</h1><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1593670560" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2020/07/02 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="1655 字" > <em>9 分钟</em>阅读</span></div></div></div></header><div class="content"><p>1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。</p><p>图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p><p>1.线性表中数据元素 叫元素 。 树-结点 图-顶点 2.图是有穷非空集合，图结构中不允许没有顶点 3.线性表中，相邻数据元素之间具有线性关系</p><p>无向边 顶点之间的边没有方向，如果任意两个顶点之间的边都是无向边，则称该图为无向图。 若两顶点之间的边有方向，则称这条边为有向边，也称为弧。 无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</p><p><a href="/assets/img/sample/wuxiangtu.png" class="popup img-link shimmer"><img src="/assets/img/sample/wuxiangtu.png" alt="图" loading="lazy"></a> <a href="/assets/img/sample/wuxiangtu1.png" class="popup img-link shimmer"><img src="/assets/img/sample/wuxiangtu1.png" alt="图" loading="lazy"></a></p><p>图的遍历 深度优先 （Depth First Search） 广度优先 (Braddth FS)</p><p>深度优先和广度优先，时间复杂度相同，不同之处仅仅在于对顶点访问的顺序不同。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.graph</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vertexList</span><span class="o">;</span> <span class="c1">//存储顶点集合</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">;</span> <span class="c1">//存储图对应的邻结矩阵</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">numOfEdges</span><span class="o">;</span> <span class="c1">//表示边的数目</span>
    <span class="c1">//定义给数组boolean[], 记录某个结点是否被访问</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//测试一把图是否创建ok</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>  <span class="c1">//结点的个数</span>
        <span class="c1">//String Vertexs[] = {"A", "B", "C", "D", "E"};</span>
        <span class="nc">String</span> <span class="nc">Vertexs</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">,</span> <span class="s">"6"</span><span class="o">,</span> <span class="s">"7"</span><span class="o">,</span> <span class="s">"8"</span><span class="o">};</span>

        <span class="c1">//创建图对象</span>
        <span class="nc">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="c1">//循环的添加顶点</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="nl">vertex:</span> <span class="nc">Vertexs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">insertVertex</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//添加边</span>
        <span class="c1">//A-B A-C B-C B-D B-E</span>
<span class="c1">//		graph.insertEdge(0, 1, 1); // A-B</span>
<span class="c1">//		graph.insertEdge(0, 2, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 2, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 3, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 4, 1); //</span>

        <span class="c1">//更新边的关系</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>



        <span class="c1">//显示一把邻结矩阵</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">showGraph</span><span class="o">();</span>

        <span class="c1">//测试一把，我们的dfs遍历是否ok</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"深度遍历"</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">dfs</span><span class="o">();</span> <span class="c1">// A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]</span>
<span class="c1">//		System.out.println();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"广度优先!"</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">bfs</span><span class="o">();</span> <span class="c1">// A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8]</span>

    <span class="o">}</span>

    <span class="c1">//构造器</span>
    <span class="kd">public</span> <span class="nf">Graph</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//初始化矩阵和vertexList</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">vertexList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">numOfEdges</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="c1">//得到第一个邻接结点的下标 w</span>
    <span class="cm">/**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFirstNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//根据前一个邻接结点的下标来获取下一个邻接结点</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNextNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//深度优先遍历算法</span>
    <span class="c1">//i 第一次就是 0</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//首先我们访问该结点,输出</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"-&gt;"</span><span class="o">);</span>
        <span class="c1">//将结点设置为已经访问</span>
        <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//查找结点i的第一个邻接结点w</span>
        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span><span class="c1">//说明有</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//如果w结点已经被访问过</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="c1">//遍历所有的结点，进行dfs[回溯]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getNumOfVertex</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//对一个结点进行广度优先遍历的方法</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">;</span> <span class="c1">// 表示队列的头结点对应下标</span>
        <span class="kt">int</span> <span class="n">w</span> <span class="o">;</span> <span class="c1">// 邻接结点w</span>
        <span class="c1">//队列，记录结点访问的顺序</span>
        <span class="nc">LinkedList</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span>
        <span class="c1">//访问结点，输出结点信息</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"=&gt;"</span><span class="o">);</span>
        <span class="c1">//标记为已访问</span>
        <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//将结点加入队列</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">//取出队列的头结点下标</span>
            <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span><span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
            <span class="c1">//得到第一个邻接结点的下标 w</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
            <span class="k">while</span><span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span><span class="c1">//找到</span>
                <span class="c1">//是否访问过</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">+</span> <span class="s">"=&gt;"</span><span class="o">);</span>
                    <span class="c1">//标记已经访问</span>
                    <span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">//入队</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//以u为前驱点，找w后面的下一个邻结点</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span> <span class="c1">//体现出我们的广度优先</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">//遍历所有的结点，都进行广度优先搜索</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getNumOfVertex</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">bfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//图中常用的方法</span>
    <span class="c1">//返回结点的个数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumOfVertex</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">//显示图对应的矩阵</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showGraph</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">link</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">link</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//得到边的数目</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumOfEdges</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">numOfEdges</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getValueByIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//返回v1和v2的权值</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">v2</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="c1">//插入结点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertVertex</span><span class="o">(</span><span class="nc">String</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vertexList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//添加边</span>
    <span class="cm">/**
     *
     * @param v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">v2</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
        <span class="n">edges</span><span class="o">[</span><span class="n">v2</span><span class="o">][</span><span class="n">v1</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
        <span class="n">numOfEdges</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/tree/" class="post-tag no-text-decoration" >tree</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%9B%BE%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure10%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%9B%BE%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure10%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure10%2F&text=%E5%9B%BE%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">最近更新</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/2024-03-11-welcome/"></a><li class="text-truncate lh-lg"> <a href="/posts/thread1/">java - 基础知识</a><li class="text-truncate lh-lg"> <a href="/posts/free-cursor/">cursor白嫖</a><li class="text-truncate lh-lg"> <a href="/posts/designpattern4/">java - 设计模式-原型模式</a><li class="text-truncate lh-lg"> <a href="/posts/java1/">java - 类加载过程</a></ul></section><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a> <a class="post-tag btn btn-outline-primary" href="/tags/tree/">tree</a> <a class="post-tag btn btn-outline-primary" href="/tags/actor/">actor</a> <a class="post-tag btn btn-outline-primary" href="/tags/akka/">akka</a> <a class="post-tag btn btn-outline-primary" href="/tags/cursor/">cursor</a> <a class="post-tag btn btn-outline-primary" href="/tags/dots/">dots</a> <a class="post-tag btn btn-outline-primary" href="/tags/ecs/">ecs</a> <a class="post-tag btn btn-outline-primary" href="/tags/hashmap/">hashmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/linkedlist/">linkedlist</a></div></section></div></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">相关文章</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/datastructure9/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1593670560" data-df="YYYY/MM/DD" > 2020/07/02 </time><h4 class="pt-0 my-2">二叉排序树 BST（Binary Sort Tree）</h4><div class="text-muted"><p>二叉排序树 二叉排序树是一颗空树或者具有以下性质二叉树 若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值 若它的右子树不为空，则右子树上所欲结点的值均大于它根结点的值 它的左右子树分别为二叉排序树 实现 package com.learn.bst; public class BinarySortTreeDemo { public static ...</p></div></div></a></article><article class="col"> <a href="/posts/thread1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1633656960" data-df="YYYY/MM/DD" > 2021/10/08 </time><h4 class="pt-0 my-2">java - 基础知识</h4><div class="text-muted"><p>内存结构 栈 存放局部变量 堆 存放对象，数组 变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内） 四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes...</p></div></div></a></article><article class="col"> <a href="/posts/datastructure8/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1592892960" data-df="YYYY/MM/DD" > 2020/06/23 </time><h4 class="pt-0 my-2">赫夫曼树</h4><div class="text-muted"><p>赫夫曼树 树的带权路径长度：树的带权路径长度规定为所有的叶子节点的带权路径长度之和（wpl 的和），wpl 最小的树就是赫夫曼树 给定 n 个权值作为 n 个叶子节点，构造一颗二叉树，若该树的带权路径达到最小（wpl），这样的二叉树称为最优二叉树。 赫夫曼树是带权路径最短的树，权越大离根结点距离越近 构建赫夫曼树 构建赫夫曼树的思路 从小到大进行排序，每个数据看成一个节点，每个...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/datastructure9/" class="btn btn-outline-primary" aria-label="上一篇" ><p>二叉排序树 BST（Binary Sort Tree）</p></a> <a href="/posts/algorithm1/" class="btn btn-outline-primary" aria-label="下一篇" ><p>常用算法 一</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/lixiao90s">晓</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.2.4" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a> <a class="post-tag btn btn-outline-primary" href="/tags/tree/">tree</a> <a class="post-tag btn btn-outline-primary" href="/tags/actor/">actor</a> <a class="post-tag btn btn-outline-primary" href="/tags/akka/">akka</a> <a class="post-tag btn btn-outline-primary" href="/tags/cursor/">cursor</a> <a class="post-tag btn btn-outline-primary" href="/tags/dots/">dots</a> <a class="post-tag btn btn-outline-primary" href="/tags/ecs/">ecs</a> <a class="post-tag btn btn-outline-primary" href="/tags/hashmap/">hashmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/linkedlist/">linkedlist</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>

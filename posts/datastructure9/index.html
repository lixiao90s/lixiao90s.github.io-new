<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="二叉排序树 BST（Binary Sort Tree）" /><meta name="author" content="晓" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="二叉排序树" /><meta property="og:description" content="二叉排序树" /><link rel="canonical" href="https://lixiao90s.github.io/posts/datastructure9/" /><meta property="og:url" content="https://lixiao90s.github.io/posts/datastructure9/" /><meta property="og:site_name" content="晓的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-02T14:16:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="二叉排序树 BST（Binary Sort Tree）" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@晓" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"晓"},"dateModified":"2020-07-02T14:16:00+08:00","datePublished":"2020-07-02T14:16:00+08:00","description":"二叉排序树","headline":"二叉排序树 BST（Binary Sort Tree）","mainEntityOfPage":{"@type":"WebPage","@id":"https://lixiao90s.github.io/posts/datastructure9/"},"url":"https://lixiao90s.github.io/posts/datastructure9/"}</script><title>二叉排序树 BST（Binary Sort Tree） | 晓的博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="晓的博客"><meta name="application-name" content="晓的博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/zh.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/sample/favicon.ico" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">晓的博客</a><p class="site-subtitle fst-italic mb-0">学习&工作记录</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>关于</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/lixiao90s" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['example','domain.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">首页</a> </span> <span>二叉排序树 BST（Binary Sort Tree）</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>二叉排序树 BST（Binary Sort Tree）</h1><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1593670560" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2020/07/02 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4821 字" > <em>26 分钟</em>阅读</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">二叉排序树 BST（Binary Sort Tree）</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">文章内容</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">二叉排序树 BST（Binary Sort Tree）</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h2 id="二叉排序树"><span class="me-2">二叉排序树</span><a href="#二叉排序树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>二叉排序树是一颗空树或者具有以下性质二叉树</p><ul><li>若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值<li>若它的右子树不为空，则右子树上所欲结点的值均大于它根结点的值<li>它的左右子树分别为二叉排序树</ul><h2 id="实现"><span class="me-2">实现</span><a href="#实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.bst</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinarySortTreeDemo</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="nc">BinarySortTree</span> <span class="n">binarySortTree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BinarySortTree</span><span class="o">();</span>
        <span class="c1">//循环的添加结点到二叉排序树</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">binarySortTree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="c1">//中序遍历二叉排序树</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"中序遍历二叉排序树~"</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span> <span class="c1">// 1, 3, 5, 7, 9, 10, 12</span>

        <span class="c1">//测试一下删除叶子结点</span>


        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">12</span><span class="o">);</span>


        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">9</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">delNode</span><span class="o">(</span><span class="mi">7</span><span class="o">);</span>


        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"root="</span> <span class="o">+</span> <span class="n">binarySortTree</span><span class="o">.</span><span class="na">getRoot</span><span class="o">());</span>


        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除结点后"</span><span class="o">);</span>
        <span class="n">binarySortTree</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">//创建二叉排序树</span>
<span class="kd">class</span> <span class="nc">BinarySortTree</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>




    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">getRoot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//查找要删除的结点</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//查找父结点</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">searchParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//编写方法:</span>
    <span class="c1">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span>
    <span class="c1">//2. 删除node 为根结点的二叉排序树的最小结点</span>
    <span class="cm">/**
     *
     * @param node 传入的结点(当做二叉排序树的根结点)
     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">delRightTreeMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="c1">//循环的查找左子节点，就会找到最小值</span>
        <span class="k">while</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//这时 target就指向了最小结点</span>
        <span class="c1">//删除最小结点</span>
        <span class="n">delNode</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">//删除结点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="c1">//1.需求先去找到要删除的结点  targetNode</span>
            <span class="nc">Node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="c1">//如果没有找到要删除的结点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">targetNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//如果我们发现当前这颗二叉排序树只有一个结点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//去找到targetNode的父结点</span>
            <span class="nc">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="c1">//如果要删除的结点是叶子结点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//判断targetNode 是父结点的左子结点，还是右子结点</span>
                <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//是左子结点</span>
                    <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="c1">//是由子结点</span>
                    <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//删除有两颗子树的节点</span>
                <span class="kt">int</span> <span class="n">minVal</span> <span class="o">=</span> <span class="n">delRightTreeMin</span><span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">minVal</span><span class="o">;</span>


            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 删除只有一颗子树的结点</span>
                <span class="c1">//如果要删除的结点有左子结点</span>
                <span class="k">if</span><span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">//如果 targetNode 是 parent 的左子结点</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//  targetNode 是 parent 的右子结点</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果要删除的结点有右子结点</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">//如果 targetNode 是 parent 的左子结点</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果 targetNode 是 parent 的右子结点</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//添加结点的方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span><span class="c1">//如果root为空则直接让root指向node</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//中序遍历</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"二叉排序树为空，不能遍历"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">//创建Node结点</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="nc">Node</span> <span class="n">right</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">//查找要删除的结点</span>
    <span class="cm">/**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//找到就是该结点</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span><span class="c1">//如果查找的值小于当前结点，向左子树递归查找</span>
            <span class="c1">//如果左子结点为空</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span>  <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果查找的值不小于当前结点，向右子树递归查找</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="c1">//查找要删除结点的父结点</span>
    <span class="cm">/**
     *
     * @param value 要找到的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有就返回null
     */</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">searchParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//如果当前结点就是要删除的结点的父结点，就返回</span>
        <span class="k">if</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">||</span>
                <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span>
            <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">//向左子树递归查找</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">//向右子树递归查找</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 没有找到父结点</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Node [value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">//添加结点的方法</span>
    <span class="c1">//递归的形式添加结点，注意需要满足二叉排序树的要求</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//判断传入的结点的值，和当前子树的根结点的值关系</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果当前结点左子结点为null</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">//递归的向左子树添加</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//添加的结点的值大于 当前结点的值</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">//递归的向右子树添加</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//中序遍历</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><h2 id="平衡二叉树avl-树"><span class="me-2">平衡二叉树（AVL 树）</span><a href="#平衡二叉树avl-树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>平衡二叉树时一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1</p><p>定义：它时一颗空树或它的左右两个子树的高度差绝对值不超过 1，并且 左右两个子树都是一颗平衡二叉树</p><p>一个 BST 左子树全部为空 从形式上看 更像一个单链表 插入速度没有影响，但是查询速度比链表更慢，因为需要判断左子树</p><p>平衡二叉树是在二叉搜索树的基础之上成立的</p><p>平衡二叉树常用实现方法有 红黑树 Avl 替罪羊树 Treap 伸展树</p><p>右子树高的时候进行左旋，左子树搞得时候进行右旋</p><p>左旋思路： 1.创建一个新节点，值等于当前根节点的值 2.把新节点的左子树设置成当前节点的左子树 3.把新节点的右子树设置为当前节点的右子节点的左子树 4.把当前节点的值换位右子节点的值 5.把当前节点的左子树设置为新节点 6.把当前节点的右子树设置成当前节点右子树的右子树</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.avl</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AVLTreeDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">// int[] arr = {4, 3, 6, 5, 7, 8};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">={</span><span class="mi">10</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span>
        <span class="nc">AVLTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AVLTree</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tree</span><span class="o">.</span><span class="na">height</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AVLTree</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">getRoot</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//查找要删除的结点</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//查找父结点</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">searchParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//编写方法:</span>
    <span class="c1">//1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span>
    <span class="c1">//2. 删除node 为根结点的二叉排序树的最小结点</span>

    <span class="cm">/**
     * @param node 传入的结点(当做二叉排序树的根结点)
     * @return 返回的 以node 为根结点的二叉排序树的最小结点的值
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">delRightTreeMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="c1">//循环的查找左子节点，就会找到最小值</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//这时 target就指向了最小结点</span>
        <span class="c1">//删除最小结点</span>
        <span class="n">delNode</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">//删除结点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//1.需求先去找到要删除的结点  targetNode</span>
            <span class="nc">Node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="c1">//如果没有找到要删除的结点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//如果我们发现当前这颗二叉排序树只有一个结点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//去找到targetNode的父结点</span>
            <span class="nc">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="c1">//如果要删除的结点是叶子结点</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//判断targetNode 是父结点的左子结点，还是右子结点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//是左子结点</span>
                    <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="c1">//是由子结点</span>
                    <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//删除有两颗子树的节点</span>
                <span class="kt">int</span> <span class="n">minVal</span> <span class="o">=</span> <span class="n">delRightTreeMin</span><span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">minVal</span><span class="o">;</span>


            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 删除只有一颗子树的结点</span>
                <span class="c1">//如果要删除的结点有左子结点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">//如果 targetNode 是 parent 的左子结点</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//  targetNode 是 parent 的右子结点</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果要删除的结点有右子结点</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">//如果 targetNode 是 parent 的左子结点</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果 targetNode 是 parent 的右子结点</span>
                            <span class="n">parent</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//添加结点的方法</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span><span class="c1">//如果root为空则直接让root指向node</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//中序遍历</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"二叉排序树为空，不能遍历"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
    <span class="c1">//创建Node结点</span>
    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">left</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">right</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>


        <span class="cm">/**
         * 左旋思路：
         * 1.创建一个新节点，值等于当前根节点的值
         * 2.把新节点的左子树设置成当前节点的左子树
         * 3.把新节点的右子树设置为当前节点的右子节点的左子树
         * 4.把当前节点的值换位右子节点的值
         * 5.把当前节点的左子树设置为新节点
         * 6.把当前节点的右子树设置成当前节点右子树的右子树
         */</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leftRotate</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="n">value</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rightRotate</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="n">value</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="n">right</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 以本节点为根节点的高度,如果只有根节点，高度则是 1
         */</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">left_height</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">right_height</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="n">left_height</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="na">height</span><span class="o">()+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="n">right_height</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="na">height</span><span class="o">()+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left_height</span><span class="o">,</span><span class="n">right_height</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 右子树高度
         * @return
         */</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rightHeight</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mHeight</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">return</span> <span class="n">right</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">mHeight</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 左子树高度
         * @return
         */</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leftHeight</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mHeight</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">mHeight</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">//查找要删除的结点</span>
        <span class="cm">/**
         * @param value 希望删除的结点的值
         * @return 如果找到返回该结点，否则返回null
         */</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//找到就是该结点</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span><span class="c1">//如果查找的值小于当前结点，向左子树递归查找</span>
                <span class="c1">//如果左子结点为空</span>
                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果查找的值不小于当前结点，向右子树递归查找</span>
                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="c1">//查找要删除结点的父结点</span>

        <span class="cm">/**
         * @param value 要找到的结点的值
         * @return 返回的是要删除的结点的父结点，如果没有就返回null
         */</span>
        <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">searchParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果当前结点就是要删除的结点的父结点，就返回</span>
            <span class="k">if</span> <span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">||</span>
                    <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">value</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">//向左子树递归查找</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">searchParent</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">//向右子树递归查找</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 没有找到父结点</span>
                <span class="o">}</span>
            <span class="o">}</span>

        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"Node [value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
        <span class="o">}</span>


        <span class="c1">//添加结点的方法</span>
        <span class="c1">//递归的形式添加结点，注意需要满足二叉排序树的要求</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">//判断传入的结点的值，和当前子树的根结点的值关系</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//如果当前结点左子结点为null</span>
                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">//递归的向左子树添加</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//添加的结点的值大于 当前结点的值</span>
                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">//递归的向右子树添加</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="o">}</span>

            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">rightHeight</span><span class="o">()-</span><span class="n">leftHeight</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">&amp;&amp;</span><span class="n">right</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">()&gt;</span><span class="n">right</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">())</span>
                <span class="o">{</span>
                    <span class="n">right</span><span class="o">.</span><span class="na">rightRotate</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">leftRotate</span><span class="o">();</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">leftHeight</span><span class="o">()-</span><span class="n">rightHeight</span><span class="o">()&gt;</span><span class="mi">1</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">&amp;&amp;</span><span class="n">left</span><span class="o">.</span><span class="na">rightHeight</span><span class="o">()&gt;</span><span class="n">left</span><span class="o">.</span><span class="na">leftHeight</span><span class="o">())</span>
                <span class="o">{</span>
                    <span class="n">left</span><span class="o">.</span><span class="na">leftRotate</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">rightRotate</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//中序遍历</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">infixOrder</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">infixOrder</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><h2 id="多路查找树"><span class="me-2">多路查找树</span><a href="#多路查找树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点可以存储多个元素。由于它时查找树，所有元素之间存在某种特定的排序关系</p><p>多路查找树 4 中特殊形式 2-3 树，2-3-4 树，b 树，b+树</p><p>在二叉树中，每个节点有数据项，最多两个子节点，如果 允许每个节点有更多的数据项和更多的子节点，就是多叉树</p><h3 id="2-3-树"><span class="me-2">2-3 树</span><a href="#2-3-树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>其中每一个结点都具有两个孩子或者三个孩子 一个 2 节点包含一个元素和两个孩子或者没有孩子 一个 3 结点包含一小一大两个元素和三个孩子或者没有孩子 2=3 树所有叶子节点都在同一层（只要是 B 树都满足这个条件） 2-3 树是由 2，3 结点构成的</p><h3 id="b-树"><span class="me-2">B 树</span><a href="#b-树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>B 树是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。 节点最大的孩子数目称为 B 树的阶 因此 2-3 树是 3 阶的 B 树，2-3-4 树 是 4 阶的 B 树。</p><p>一个 m 阶的 b 树具有如下属性 如果根结点不是叶子结点，则至少有两颗子树 每一个非根的分支节点都有 k-1 个元素和 k 个孩子，其中 m/2&lt;=k&lt;=m 每一个叶子节点 n 都有 k-1 个元素，其中 m/2&lt;=k&lt;=m. 所有叶子节点都位于同一层次</p><p>B 树上查找的过程式一个顺指针查找结点和再结点中查找关键字的交叉过程</p><p>B 树是怎么做到减少内存与外存交换数据的</p><p>外存，比如硬盘，将所有信息分割成相等大小的页面，每次硬盘读写都是一个 或多个完整的页面，对于一个硬盘来说，一页的长度可能是 211 到 214 个字节。</p><p>在一个典型的 B 树应用中，要处理的硬盘数据量很大，因此无法一次全部装入 到内存。因此我们会对 B 树进行调整，使得 B 树的阶数（结点的元素）与硬盘存储 的页面大小相匹配。通过这种方式，在有限内存的情况下，每一次磁盘的访问我们 都可以获得最大数据量的数据。由于 b 树每结点可以具有比二叉树多得多的元素 ，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能 。可以说，b 树的数据结构就是为内外存的数据交互准备的。</p><h3 id="b树"><span class="me-2">B+树</span><a href="#b树" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>对于树结构来说，我们可以通过中序遍历来顺序查找树中的元素，这一切都是在 内存中进行。 可是在 b 树结构中，我们往返于每个节点之间意味着，我们必须得在硬盘的页面 之间进行多次访问。为了能够解决所有元素遍历等基本问题，我们在 原有的 B 树结构基础上，加上了新的元素组织方式，这就是 B+树。 B+树是应文件系统所需而出的一种 B 树的变形树，严格意义上讲，不是数据 结构定义的树了。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/tree/" class="post-tag no-text-decoration" >tree</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20BST%EF%BC%88Binary%20Sort%20Tree%EF%BC%89%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure9%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20BST%EF%BC%88Binary%20Sort%20Tree%EF%BC%89%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure9%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Flixiao90s.github.io%2Fposts%2Fdatastructure9%2F&text=%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%20BST%EF%BC%88Binary%20Sort%20Tree%EF%BC%89%20-%20%E6%99%93%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">最近更新</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/2024-03-11-welcome/"></a><li class="text-truncate lh-lg"> <a href="/posts/thread1/">java - 基础知识</a><li class="text-truncate lh-lg"> <a href="/posts/free-cursor/">cursor白嫖</a><li class="text-truncate lh-lg"> <a href="/posts/designpattern4/">java - 设计模式-原型模式</a><li class="text-truncate lh-lg"> <a href="/posts/java1/">java - 类加载过程</a></ul></section><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a> <a class="post-tag btn btn-outline-primary" href="/tags/tree/">tree</a> <a class="post-tag btn btn-outline-primary" href="/tags/actor/">actor</a> <a class="post-tag btn btn-outline-primary" href="/tags/akka/">akka</a> <a class="post-tag btn btn-outline-primary" href="/tags/cursor/">cursor</a> <a class="post-tag btn btn-outline-primary" href="/tags/dots/">dots</a> <a class="post-tag btn btn-outline-primary" href="/tags/ecs/">ecs</a> <a class="post-tag btn btn-outline-primary" href="/tags/hashmap/">hashmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/linkedlist/">linkedlist</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">文章内容</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">相关文章</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/datastructure10/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1593670560" data-df="YYYY/MM/DD" > 2020/07/02 </time><h4 class="pt-0 my-2">图</h4><div class="text-muted"><p>1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。 图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中...</p></div></div></a></article><article class="col"> <a href="/posts/thread1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1633656960" data-df="YYYY/MM/DD" > 2021/10/08 </time><h4 class="pt-0 my-2">java - 基础知识</h4><div class="text-muted"><p>内存结构 栈 存放局部变量 堆 存放对象，数组 变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内） 四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes...</p></div></div></a></article><article class="col"> <a href="/posts/datastructure8/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1592892960" data-df="YYYY/MM/DD" > 2020/06/23 </time><h4 class="pt-0 my-2">赫夫曼树</h4><div class="text-muted"><p>赫夫曼树 树的带权路径长度：树的带权路径长度规定为所有的叶子节点的带权路径长度之和（wpl 的和），wpl 最小的树就是赫夫曼树 给定 n 个权值作为 n 个叶子节点，构造一颗二叉树，若该树的带权路径达到最小（wpl），这样的二叉树称为最优二叉树。 赫夫曼树是带权路径最短的树，权越大离根结点距离越近 构建赫夫曼树 构建赫夫曼树的思路 从小到大进行排序，每个数据看成一个节点，每个...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/datastructure8/" class="btn btn-outline-primary" aria-label="上一篇" ><p>赫夫曼树</p></a> <a href="/posts/datastructure10/" class="btn btn-outline-primary" aria-label="下一篇" ><p>图</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/lixiao90s">晓</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.2.4" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/shader/">shader</a> <a class="post-tag btn btn-outline-primary" href="/tags/java/">java</a> <a class="post-tag btn btn-outline-primary" href="/tags/tree/">tree</a> <a class="post-tag btn btn-outline-primary" href="/tags/actor/">actor</a> <a class="post-tag btn btn-outline-primary" href="/tags/akka/">akka</a> <a class="post-tag btn btn-outline-primary" href="/tags/cursor/">cursor</a> <a class="post-tag btn btn-outline-primary" href="/tags/dots/">dots</a> <a class="post-tag btn btn-outline-primary" href="/tags/ecs/">ecs</a> <a class="post-tag btn btn-outline-primary" href="/tags/hashmap/">hashmap</a> <a class="post-tag btn btn-outline-primary" href="/tags/linkedlist/">linkedlist</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>

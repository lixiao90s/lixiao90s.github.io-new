<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2025-03-12T00:46:29+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">晓的博客</title><subtitle>记录学习 工作。</subtitle><entry><title type="html">欢迎来到我的博客</title><link href="http://localhost:4000/posts/welcome/" rel="alternate" type="text/html" title="欢迎来到我的博客" /><published>2024-03-11T12:00:00+08:00</published><updated>2024-03-11T12:00:00+08:00</updated><id>http://localhost:4000/posts/welcome</id><content type="html" xml:base="http://localhost:4000/posts/welcome/"><![CDATA[<h2 id="欢迎">欢迎</h2>

<p>欢迎来到我的技术博客！这里将会分享各种编程技术和经验。</p>

<h2 id="关于本站">关于本站</h2>

<p>本站使用 Jekyll 搭建，采用 Chirpy 主题。主要关注以下技术领域：</p>

<ul>
  <li>Java 开发</li>
  <li>Python 编程</li>
  <li>Web 开发</li>
  <li>数据库技术</li>
  <li>DevOps 实践</li>
</ul>

<h2 id="未来计划">未来计划</h2>

<p>我会定期更新以下内容：</p>

<ol>
  <li>技术教程</li>
  <li>编程心得</li>
  <li>项目经验分享</li>
  <li>新技术探索</li>
</ol>

<p>敬请期待！</p>]]></content><author><name></name></author><category term="公告" /><category term="博客" /><category term="欢迎" /><summary type="html"><![CDATA[欢迎]]></summary></entry><entry><title type="html">java - 基础知识</title><link href="http://localhost:4000/posts/thread1/" rel="alternate" type="text/html" title="java - 基础知识" /><published>2021-10-08T09:36:00+08:00</published><updated>2021-10-08T09:36:00+08:00</updated><id>http://localhost:4000/posts/thread1</id><content type="html" xml:base="http://localhost:4000/posts/thread1/"><![CDATA[<h2 id="内存结构">内存结构</h2>
<ul>
  <li>栈 存放局部变量</li>
  <li>
    <p>堆 存放对象，数组</p>
  </li>
  <li>变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内）</li>
</ul>

<h2 id="四种访问权限修饰符">四种访问权限修饰符</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">修饰符</th>
      <th style="text-align: left">类内部</th>
      <th style="text-align: left">同一个包</th>
      <th style="text-align: left">不同包的子类</th>
      <th style="text-align: left">同一个工程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">private</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">default</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">protected</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">public</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
      <td style="text-align: left">yes</td>
    </tr>
  </tbody>
</table>

<p>对于class的修饰符只有public 和default</p>

<h1 id="javabean-符合以下标准的类">JavaBean 符合以下标准的类</h1>
<ul>
  <li>类是公共的</li>
  <li>有一个无参的公共构造器</li>
  <li>有属性，且有对应的get,set方法</li>
</ul>

<p>用户可以使用JavaBean 将功能，处理，值，数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet,其他JavaBean,applet程序或者应用来使用这些对象。用户可以认为JavaBean 提供了一种随时随地的复制和赞贴的功能，而不用关心任何改变。</p>

<h1 id="this">this</h1>
<ul>
  <li>this可以调用属性，方法，构造器</li>
  <li>this() 调用构造器，可以显示的使用this(形参列表)方式，调用指定的其他构造器，不能形成递归</li>
</ul>

<h1 id="继承">继承</h1>
<ul>
  <li>子类继承后，具有父类的所有属性和方法 ，private属性和方法仍然认为获取到了，但是因为封装的原因，不能直接调用</li>
  <li>所有的java类处 java.lang.Object 外，都直接或者间接继承了java.lang.Object类</li>
  <li>当子类和父类中定义同名属性时，我们想要在子类调用父类中的属性方式，必须使用“super.属性”，子类不会覆盖父类的属性</li>
  <li>我们可以在子类构造器中显示的使用super(形参列表)，调用父类的构造器，必须声明在子类构造器的首行</li>
  <li>在构造器的首行没有显示的声明this(形参列表)或super(形参列表)，则默认调用的是父类的空参的构造函数</li>
</ul>

<h2 id="子类对象的实例化过程">子类对象的实例化过程</h2>

<ul>
  <li>从结果来看 子类继承父类以后，就获取了父类所有的属性和方法</li>
  <li>创建子类的对象后，在堆空间中，就会加载所有父类中声明的属性</li>
  <li>从过程看 当我们通过子类的构造器创建子类对象时，我们一定会直接或者间接的调用父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有父类的结构，所有内存中才会有所有父类的结构，并且使用。</li>
  <li>虽然创建子类对象时，调用了父类的构造器，但是只创建了一个对象，就是new 出来的对象</li>
</ul>

<h1 id="多态性">多态性</h1>

<ul>
  <li>对象的多态性，父类的引用指向子类的对象</li>
</ul>

<h2 id="多态的使用">多态的使用</h2>
<ul>
  <li>当调用子父类同名同参方法时，执行的是子类重写父类的方法</li>
  <li>编译期，只能调用父类中声明的方法 ，但是运行期，我们实际执行的是子类重写的方法 只适用方法，编译看左边，运行看右边</li>
  <li>对象的多态性，只使用于方法，不适用于属性。 编译和运行都看左边。</li>
  <li>虚拟方法调用 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它不同子类对象，动态调用属于子类的的该方法，这样的方法调用在编译器是无法确定的。</li>
  <li>编译时类型和运行时类型。方法调用是在运行时确定的，动态绑定。</li>
  <li>多态是个运行时行为</li>
  <li>若子类重写了父类的方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类的的方法转移到子类中。（编译看左边，运行看右边）</li>
  <li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量（编译运行都看左边）</li>
</ul>

<p>## 方法的重写</p>
<ul>
  <li>方法名，形参列表相同</li>
  <li>权限修饰符不能小于父类，不能重写private权限的方法</li>
  <li>返回值不能大于父类的返回类型，</li>
  <li>static 方法不涉及到重写</li>
</ul>

<h2 id="静态变量">静态变量</h2>

<ul>
  <li>静态变量随着类的加载而加载</li>
  <li>静态变量加载要早于对象的创建</li>
  <li>类只会加载一次， 静态变量也只会存在一份</li>
</ul>

<h2 id="静态方法">静态方法</h2>
<ul>
  <li>只能调用静态变量或者其他静态方法，因为是随着类的加载而加载，其他实例变量还没有，所以this,super是不能用的。</li>
</ul>

<h2 id="栈堆方法区">栈，堆，方法区</h2>
<ul>
  <li>栈，静态变量</li>
  <li>堆：new 出来的结构 对象，数组</li>
  <li>方法区： 类的加载信息，静态域，常量池</li>
</ul>

<h2 id="抽象与接口">抽象与接口</h2>

<h3 id="抽象">抽象</h3>
<ul>
  <li>抽象类，不可以实例化，一定有构造器，便于子类实例化时调用，通常在开发中，都会提供抽象类的子类，让子类对象实例化。</li>
  <li>抽象方法，没有方法体，只有声明。 抽象方法一定是在抽象类。</li>
  <li>若子类重写了父类的所有 抽象方法后，则此子类可以实例化，若子类没有重写父类的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰。</li>
</ul>

<h3 id="接口">接口</h3>
<ul>
  <li>interface和类是并列的结构，通过implements</li>
  <li>如何定义接口：JDK7及以前 只能定义全局常量和抽象方法（public static final（书写时可以省略）,public abstarct）</li>
  <li>JDK8 新增了 静态方法和默认方法。</li>
  <li>接口中是不可以定义构造器的，意味着接口不可以实例化</li>
  <li>如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化，如果没有则实现类认为接口</li>
  <li>java类可以实现多个接口，弥补了java单继承性</li>
  <li>接口与接口之间可以继承，并且可以多继承 
 ### jdk8 新特性</li>
  <li>静态方法和默认方法</li>
  <li>接口中定义的静态方法，只能通过接口调用</li>
  <li>通过实现类的对象，可以调用接口中的默认方法</li>
  <li>如果子类继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数默认（default）方法</li>
  <li>接口冲突： 如果实现类实现了多个接口，而这多个接口中定了同名同参数的默认方法，那么实现类没有重写此方法的情况下报错</li>
  <li>调用接口中的默认方法 Interface.super.method（）</li>
</ul>

<p>## 抽象类和接口的共同点以及区别</p>
<ul>
  <li>相同点： 不能实例化，都可以被继承</li>
  <li>不同 抽象类：有构造器， 接口：不能声明构造器 ，类单继承，接口可以多继承</li>
</ul>

<h2 id="异常处理">异常处理</h2>
<p>### ERROR 
    一般不编写针对性的代码进行处理
    java虚拟机无法解决的严重问题，如JVM系统内部错误，资源耗尽等严重情况，例如栈溢出：StackOverflowError,堆溢出：OutOfMemoryError,</p>

<p>### Exception</p>
<ul>
  <li>其他编程错误或偶然的外在因素导致的，可以使用针对性的代码进行处理</li>
  <li>例如空指针，数组越界，除数为0</li>
  <li>一般两种解决方法，遇到错误终止程序的运行。另一种方法时由程序编写程序时，考虑到错误的检测，错误消息的提示，以及处理。</li>
  <li>finally 是可选的，finally 中声明的是一定会被执行的代码，即使catch中又出了异常，try中有return语句，catch中有return
  语句等， 也会先执行finally的语句。</li>
  <li>像数据库连接，输入输出流，网络编程Socket 等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中
  ### 体会
    <ul>
      <li>使用try-catch-finally 处理编译时异常，是将编译时可能出现的异常，延迟到运行时出现</li>
      <li>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时编译try-catch-finally</li>
    </ul>
  </li>
</ul>]]></content><author><name>晓</name></author><category term="java" /><category term="java" /><summary type="html"><![CDATA[内存结构 栈 存放局部变量 堆 存放对象，数组]]></summary></entry><entry><title type="html">java - 设计模式-原型模式</title><link href="http://localhost:4000/posts/designpattern4/" rel="alternate" type="text/html" title="java - 设计模式-原型模式" /><published>2021-01-08T09:36:00+08:00</published><updated>2021-01-08T09:36:00+08:00</updated><id>http://localhost:4000/posts/designpattern4</id><content type="html" xml:base="http://localhost:4000/posts/designpattern4/"><![CDATA[<h2 id="原型模式prototype">原型模式（ProtoType）</h2>

<ul>
  <li>用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li>
  <li>原型模式是一种创建型模式，允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节</li>
  <li>工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone</li>
</ul>

<p><img src="/assets/img/sample/protoType.png" alt="图" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>
<span class="kn">package</span> <span class="nn">CreationalPattern.ProtoTypePattern</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">ProtoType</span> <span class="n">pt1</span> <span class="o">=</span><span class="k">new</span> <span class="nc">ProtoType</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">ProtoType</span> <span class="n">pt2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProtoType</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">pt1</span><span class="o">.</span><span class="na">setProtoType</span><span class="o">(</span><span class="n">pt2</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pt1</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">ProtoType</span> <span class="n">pt3</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ProtoType</span><span class="o">)</span> <span class="n">pt1</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pt3</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">CreationalPattern.ProtoTypePattern</span><span class="o">;</span>

<span class="cm">/**
 * 原型模式
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProtoType</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setProtoType</span><span class="o">(</span><span class="nc">ProtoType</span> <span class="n">protoType</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">protoType</span> <span class="o">=</span> <span class="n">protoType</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">ProtoType</span> <span class="n">protoType</span><span class="o">;</span>



    <span class="kd">public</span> <span class="nf">ProtoType</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="s">"id:"</span><span class="o">+</span><span class="n">id</span><span class="o">+</span><span class="s">" protoType:"</span><span class="o">+</span><span class="n">protoType</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span> <span class="o">{</span>
        <span class="nc">ProtoType</span> <span class="n">protoType</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
           <span class="n">protoType</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ProtoType</span><span class="o">)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">protoType</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="输出结果">输出结果</h2>

<p>id:1 protoType:603742814
id:1 protoType:603742814</p>

<p>对于引用传递的对象再克隆的时候，传递的是地址，这里克隆模式使用的是<strong>浅拷贝</strong></p>

<h2 id="浅拷贝">浅拷贝</h2>

<ul>
  <li>对于数据类型是基本数据类型的成员变量，直接进行值传递</li>
  <li>对于引用类型的成员变量，例如数组，或者成员对象，浅拷贝进行引用传递，也就是只会复制地址，<strong>在一个对象修改该成员变量，会影响到另一个对象的该成员变量值</strong></li>
</ul>

<h2 id="深拷贝">深拷贝</h2>

<ul>
  <li>复制对象的所有基本数据类型的成员变量值</li>
  <li>为所还有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达到所有的对象。</li>
</ul>

<h3 id="深拷贝实现">深拷贝实现</h3>

<ul>
  <li>重写 clone 方法来实现深拷贝</li>
  <li>对象序列化实现深拷贝</li>
</ul>]]></content><author><name>晓</name></author><category term="java" /><category term="原型模式" /><summary type="html"><![CDATA[原型模式（ProtoType）]]></summary></entry><entry><title type="html">java - 类加载过程</title><link href="http://localhost:4000/posts/java1/" rel="alternate" type="text/html" title="java - 类加载过程" /><published>2021-01-03T09:36:00+08:00</published><updated>2021-01-03T09:36:00+08:00</updated><id>http://localhost:4000/posts/java1</id><content type="html" xml:base="http://localhost:4000/posts/java1/"><![CDATA[<h2 id="类加载过程">类加载过程</h2>

<h3 id="初始化">初始化</h3>

<ul>
  <li>一个类要实例化需要先加载并初始化该类
    <ul>
      <li>main 所在的类需要先加载和初始化</li>
    </ul>
  </li>
  <li>一个子类要初始化需要先初始化父类</li>
  <li>一个类初始化就是执行&lt; clinit &gt;（） 方法
    <ul>
      <li>&lt; clinit &gt;() 方法由静态类静态变量显示赋值代码和静态代码块组成</li>
      <li>类变量显示赋值代码和静态代码块从上到下顺序执行</li>
      <li>&lt; clinit &gt;()方法只执行一次</li>
    </ul>
  </li>
</ul>

<h3 id="实例初始化">实例初始化</h3>

<ul>
  <li>实例初始化就是执行&lt; init &gt;() 方法</li>
  <li>&lt; init &gt;() 方法可能重载有多个，有几个构造器就有几个&lt; init &gt;()方法</li>
  <li>&lt; init &gt;() 方法由非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而构造器的代码最后执行</li>
  <li>每次创建实例对象，调用对应构造器，执行的就是对应&lt; init &gt;()方法</li>
  <li>&lt; init &gt;方法的首行是 super（）或 super（实参列表），即对应父类&lt; init &gt;方法</li>
</ul>

<h2 id="方法的重写">方法的重写</h2>

<ul>
  <li>不可重写的方法
    <ul>
      <li>final 方法</li>
      <li>静态方法</li>
      <li>private 等子类中不可见方法</li>
    </ul>
  </li>
  <li>非静态方法前面都有个 this，this 在&lt; init &gt; 表示的是正在创建的对象</li>
</ul>

<h2 id="对象的多态性">对象的多态性</h2>

<ul>
  <li>子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码</li>
  <li>非静态方法默认的调用对象时 this</li>
  <li>this 堆在在构造器或者说&lt; init &gt;方法中就是正在创建的队形</li>
</ul>]]></content><author><name>晓</name></author><category term="java" /><category term="类加载过程" /><summary type="html"><![CDATA[类加载过程]]></summary></entry><entry><title type="html">设计模式 - 单例</title><link href="http://localhost:4000/posts/designpattern3/" rel="alternate" type="text/html" title="设计模式 - 单例" /><published>2020-12-20T09:36:00+08:00</published><updated>2020-12-20T09:36:00+08:00</updated><id>http://localhost:4000/posts/designpattern3</id><content type="html" xml:base="http://localhost:4000/posts/designpattern3/"><![CDATA[<h2 id="单例模式">单例模式</h2>

<p>采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例，
并且该类只提供一个取得其对象实例的方法（静态方法）</p>

<h3 id="八种方式">八种方式</h3>

<ul>
  <li>饿汉式（静态常量）</li>
  <li>
    <p>饿汉式（静态代码块）</p>
  </li>
  <li>懒汉式（线程不安全）</li>
  <li>懒汉式（线程安全，同步方法）</li>
  <li>
    <p>懒汉式（线程安全，同步代码块）</p>
  </li>
  <li>双重检查</li>
  <li>静态内部类</li>
  <li>枚举</li>
</ul>

<h3 id="饿汉式静态常量">饿汉式（静态常量）</h3>

<p>1.构造器私有化（防止 new 出新实例） 2.类的内部创建对象 3.向外暴露一个静态方法（获取实例）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton7</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton7</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonInstance</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton7</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton7</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span>  <span class="nc">Singleton7</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="nc">SingletonInstance</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>优点：写法简单，类装载的时候完成实例化，避免线程安全问题
缺点：类装载的时候完成实例化，没有 lazy loading 效果，如果自始至终没有用到单例，会造成内存浪费</p>

<p>这种方式基于 classloader 机制避免了多线程的同步问题，不过，intance 在装载时就实例化，单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因很多，不能确定有其他的方式导致类装载，这时候初始化 instance 没有达到 lazy loading 的效果。</p>

<h3 id="饿汉式静态代码块">饿汉式（静态代码块）</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="n">packagepattern</span><span class="o">.</span><span class="na">Singleton</span><span class="o">;</span>


<span class="cm">/**
 * 饿汉式 静态代码块
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton2</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton2</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span>  <span class="kd">static</span> <span class="nc">Singleton2</span> <span class="n">instance</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton2</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton2</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>类实例化的过程放在了静态代码块中，也是类装载的时候，就执行了静态代码块的中的代码，初始化类的实例。优缺点和上面相同。</p>

<h3 id="懒汉式线程不安全">懒汉式（线程不安全）</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * 懒汉式 线程不安全 lazy loading
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton3</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton3</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span>  <span class="kd">static</span> <span class="nc">Singleton3</span> <span class="n">instance</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton3</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton3</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>1.起到了 lazy loading 的效果，但是只能单线程下使用. 2.如果在多线程下，多个线程同时进入 if 语句，就会产生多个实例</p>

<h3 id="饿汉式线程安全">饿汉式（线程安全）</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * 懒汉式，线程安全，同步方法
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton4</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton4</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span>  <span class="kd">static</span> <span class="nc">Singleton4</span> <span class="n">instance</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">Singleton4</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton4</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>优点：线程安全
缺点：效率太低，每个线程想要获取实例执行 getInstance 都要进行同步，但是该方法只需要执行一次，实例化后直接 return 就好了</p>

<p>实际开发不推荐</p>

<h3 id="双重检查">双重检查</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * Double Check 双重检查
 * 优点： 线程安全，懒加载，getInstance方法效率也提高了
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton6</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton6</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleton6</span> <span class="n">instance</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span>  <span class="nc">Singleton6</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Singleton6</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton6</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>推荐使用的方法
优缺点：
线程安全，延迟加载，效率较高
第一个 instance==null 不为空则直接返回，避免方法每次访问同步
第二个 instance==null 保证了线程安全
这样保证了效率和线程安全，在实际开发中推荐这样使用</p>

<h3 id="静态内部类">静态内部类</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * 静态内部类方法
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton7</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton7</span><span class="o">()</span>
    <span class="o">{</span>

    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonInstance</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton7</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton7</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span>  <span class="nc">Singleton7</span> <span class="nf">getInstance</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="nc">SingletonInstance</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>1.这种方式采用了类装载的机制来保证初始化实例只有一个线程 2.静态内部类在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载静态内部类 SingletonInstance，从而完成 Singleton 的实例化，提高了效率 3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程安全，在类进行初始化时，别的线程是无法进入的，避免线程不安全。</p>

<p>推荐使用</p>

<h3 id="总结">总结</h3>

<ul>
  <li>单例模式保证系统中该类只有这一个对象，节省了系统资源，对于频繁创建销毁的对象，使用单例模式可以系统性能</li>
  <li>当想使用一个实例时，只能用 getInstance，不能 new</li>
  <li>单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象
工具类对象，频繁访问数据库或文件的对象（比如数据源，session 工厂等）</li>
</ul>]]></content><author><name>晓</name></author><category term="设计模式" /><category term="单例" /><summary type="html"><![CDATA[单例模式]]></summary></entry><entry><title type="html">设计模式 - 设计模式的原则</title><link href="http://localhost:4000/posts/designpattern2/" rel="alternate" type="text/html" title="设计模式 - 设计模式的原则" /><published>2020-12-06T09:36:00+08:00</published><updated>2020-12-06T09:36:00+08:00</updated><id>http://localhost:4000/posts/designpattern2</id><content type="html" xml:base="http://localhost:4000/posts/designpattern2/"><![CDATA[<h2 id="七大原则">七大原则</h2>

<h3 id="单一职责原则">单一职责原则</h3>

<p>单一职责原则（Single Responsibility Principle, SRP）： 一个类只负责一个功能领域中的相 应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>

<h3 id="开闭原则">开闭原则</h3>

<p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件 实体应尽量在不修改原有代码的情况下进行扩展。
在 Java、C#等 编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现 层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系 统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何 改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩 展系统的功能，达到开闭原则的要求。</p>

<h3 id="里式替换原则">里式替换原则</h3>

<p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类 （父类）的地方必须能透明地使用其子类的对象。
里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立。
里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对 象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用 子类对象来替换父类对象。
(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代 换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在 子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现 父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地 扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类 来实现。里氏代换原则是开闭原则的具体实现手段之一。</p>

<h3 id="依赖倒转原则">依赖倒转原则</h3>

<p>依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应 当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据 类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只 实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增 加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体 类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭 原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发 生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注 入，设值注入（Setter 注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象， 设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务 方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型 的对象，由子类对象来覆盖父类对象。</p>

<h3 id="接口隔离原则">接口隔离原则</h3>

<p>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。</p>

<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干 不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具 有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义， 有严格的定义和结构，比如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以 及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概 念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角 色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端 需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的 所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口 中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便， 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只 包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即 为不同的客户端提供宽窄不同的接口。</p>

<h3 id="合成复用原则">合成复用原则</h3>

<p>合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复 用的目的。</p>

<p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些 已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能 的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p>

<p>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低 类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使 用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂 度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继 承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是 静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。
由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新 对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现 细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对 较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用 成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型 相同的其他对象。</p>

<h3 id="迪米特原则">迪米特原则</h3>

<p>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>

<p>迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪 米特法则中，对于一个对象，其朋友包括以下几类：</p>

<ul>
  <li>(1) 当前对象本身(this)；</li>
  <li>(2) 以参数形式传入到当前对象方法中的对象；</li>
  <li>(3) 当前对象的成员对象；</li>
  <li>(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>
  <li>(5) 当前对象所创建的对象。</li>
</ul>]]></content><author><name>晓</name></author><category term="设计模式" /><category term="设计模式的原则" /><summary type="html"><![CDATA[七大原则]]></summary></entry><entry><title type="html">Akka 入门-Actor</title><link href="http://localhost:4000/posts/akka1/" rel="alternate" type="text/html" title="Akka 入门-Actor" /><published>2020-10-17T00:16:00+08:00</published><updated>2020-10-17T00:16:00+08:00</updated><id>http://localhost:4000/posts/akka1</id><content type="html" xml:base="http://localhost:4000/posts/akka1/"><![CDATA[<h2 id="模块">模块</h2>

<p>AKKA 是调度模块化的，它由许多拥有不同特性的 JAR 组成。</p>

<ul>
  <li>akka-actor – 经典角色、类型角色、IO 角色等。</li>
  <li>akka-agent – 代理、整合了 Scala 的 STM 特性</li>
  <li>akka-camel – 整合 Apache 的 Camel</li>
  <li>akka-cluster – 集群成员管理、弹性路由</li>
  <li>akka-kernel – AKKA 微内核，运行着一个极简应用服务器</li>
  <li>akka-osgi – 在 OSG 容器里使用 AKKA 的基本 bundle，包括 akka-actor 的类</li>
  <li>akka-osgi-aries – Aries——服务提供角色系统的蓝图</li>
  <li>akka-remote – 远程角色</li>
  <li>akka-slf4j – SLF4J Logger (事件总线监听器)</li>
  <li>akka-testkit – 测试角色系统的工具包 Toolkit for testing Actor systems</li>
  <li>akka-zeromq – 整合 ZeroM</li>
</ul>

<h2 id="actor">Actor</h2>

<ul>
  <li>
    <p>角色（Actor）</p>

    <ul>
      <li>并发与并行性的高等级抽象</li>
      <li>异步，无锁以及高性能的事件驱动编程模型</li>
      <li>非常轻量级的事件驱动流程</li>
    </ul>
  </li>
  <li>容错
    <ul>
      <li>拥有“让它崩溃”语义的管理层级</li>
      <li>管理层级可以跨越多个 JVM，实现真正的容错系统</li>
      <li>非常适合编写可自我修复且永不停机的高容错能力的系统</li>
    </ul>
  </li>
  <li>位置透明
    <ul>
      <li>akka 旨在分布式环境中工作：角色之间都是用纯消息交互，并且一切都是异步的</li>
    </ul>
  </li>
</ul>

<h3 id="actor-优点">Actor 优点</h3>

<ul>
  <li>事件驱动模型：Event-driven model，Actor 通过响应消息来执行工作。Actor 之间的通信是异步的，允许 Actor 发送消息并继续自己的工作，而不是阻塞等待响应</li>
  <li>强隔离原则：Strong isolation principles，与 Java 中的常规对象不同，Actor 在调用的方法方面，没有一个公共 API。相反，它的公共 API 是通过 Actor 处理的消息来定义的。这可以防止 Actor 之间共享状态；观察另一个 Actor 状态的唯一方法是向其发送请求状态的消息。</li>
  <li>位置透明：Location transparency，系统通过工厂方法构造 Actor 并返回对实例的引用。因为位置无关紧要，所以 Actor 实例可以启动、停止、移动和重新启动，以向上和向下扩展以及从意外故障中恢复</li>
  <li>轻量级：Lightweight，每个实例只消耗几百个字节，这实际上允许数百万并发 Actor 存在于一个应用程序中。</li>
</ul>

<h3 id="actor-生命周期">Actor 生命周期</h3>

<p>actor 被创建后存在，并且用户请求关闭消失。当 actor 被关闭后，其所有的子 actor 都将被递归地关闭。这个特性极大简化了我们的资源清理工作，并且防止资源泄露。实际上，在进行底层多线程编程时，我们经常会小看各种对并发资源生命周期管理的难度。
Context.stop(self)自我关闭，停止其他 Context.stop(actorRef) 通过这种方式停止一个 actor 是坏习惯，但是你可以给这个 actor 发送 PosionPill 或者自定义关闭消息来关闭它。</p>

<p>Akka 的 actor 提供了很对生命周期 API，你可以在实现 actor 时重载这些方法。最常用的是 preStart()和 postStop()。
preStart()会在 actor 启动后，并在它处理第一个消息之前被调用
postStop()会在 actor 将要被关闭前被调用，在它之后，actor 不会再处理任何消息了</p>

<h3 id="actor-层次结构">Actor 层次结构</h3>

<p>通过调用 context.actorOf 创建一个 actor。这种方式向现有的 actor 树内加入了一个新的 actor，这个 actor 创建者
就成为了这个 actor 的父 actor。
所有的 actor 都有一个共同的家长 成为 user guardian 可以通过调用 system.actorOf()来创建属于它新的 actor 实例。创建 actor 将返回一个有效的 URL 引用，因此，如果我们通过调用 system.actorOf(…,”someActor”) 创建一个名为 someActor 时，其引用将包路径/user/someActor</p>

<p><img src="/assets/actor-hierarchy.png" alt="图" /></p>

<h3 id="actor-失败处理">Actor 失败处理</h3>

<p>父 actor 和子 actor 在整个声明周期内都保持着联系。当一个 actor 失败了（抛出异常或者在 receive 里冒出一个未处理的异常），他会被暂时地挂起。就像之前提到的一样，失败信息会被传递到父 actor 中，然后由父 actor 来决定如何处理这个子 actor 产生的异常。在这种方式下，父 actor 就是子 actor 的监管者，默认的监管策略就是停止并且重启子 actor。如果你没有修改默认的监管策略，那么所有的失败都会导致重启 actor。
到在 actor 失败后，被监管的 actor 被立即停止并重启，我们也看到了一条这个异常被处理的日志。在测试中，我们使用 preStart()和 postStop()钩子，这些钩子可以在 actor 被重启前后被调用，所以我们不能用它来区分 actor 是我吃一次启动还是被重启。重启 actor 在大多数情况是正确的，重启可以让 actor 恢复到一个已知的正确状态上，也就是启动时的干净状态。在内部真正发生的是：<strong>preRestart()</strong>和<strong>postRestart()</strong> 方法被调用，如果它们没有被重载，则它们分别会调用 postStop()和 preStart()你可以尝试重载这些方法，看看输出的改变</p>

<h3 id="actor-处理子角色故障">Actor 处理子角色故障</h3>

<p>角色最后一个功能是处理子角色的故障。故障处理对于用户来说是透明的，对于发生的故障 Akka 都会自动的通过对应策略处理（监管和监测章节介绍）。 因为这些策略是构成角色系统的基础，所以一旦角色被创建那么这些故障处理策略将不可改变。
由于每个角色都只有一类故障处理策略，这也就意味着不同的子角色将会应用不同的策略。角色根据子角色所使用的故障处理策略将它们分组。根据任务被切分的子任务性质系统会不断的重复这个分组过程。一旦角色终止，如失败后无法重启，自己停止或者被监督者停止，那么它将释放它占有的所有资源，并将它信箱中没处理的消息发送到“死信件信箱”里，然后“死信件信箱”将会把他们以 <strong>DeadLetters</strong> 的形式传递给 EventStream. Actor 引用中的信箱将会被一个系统信箱所取代，然后将所有消息以 <strong>DeadLetters</strong> 的形式转发给 EventStream。虽然系统会尽最大努力来实现该消息传递，但是我们不能依赖它来实现“有保证的传递”。
为什么不选择悄悄的将所有消息倾倒出来，是基于我们下面的测试结果考虑：我们在事件总线（BUS）上注册了测试事件监听器(TestEventListener)。这里事件总线即死信件被发送到的地方。该监听器将会对收到的每条死信件记录一条警告日志——这个可以帮助我们更快的检测失败。所以我们有理由相信这个特征还将可以应用于其他目的。</p>]]></content><author><name>晓</name></author><category term="框架" /><category term="akka" /><category term="actor" /><summary type="html"><![CDATA[模块]]></summary></entry><entry><title type="html">常用算法 一</title><link href="http://localhost:4000/posts/datastructure11/" rel="alternate" type="text/html" title="常用算法 一" /><published>2020-07-12T14:16:00+08:00</published><updated>2020-07-12T14:16:00+08:00</updated><id>http://localhost:4000/posts/datastructure11</id><content type="html" xml:base="http://localhost:4000/posts/datastructure11/"><![CDATA[<h2 id="常用算法">常用算法</h2>

<h3 id="非递归二分查找实现">非递归二分查找实现</h3>

<p>二分查找只适用于有序查找，需要先将数列进行排序</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.bsc</span><span class="o">;</span>

<span class="cm">/**
 * 非递归二分查找
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BsNoRecur</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearchNoRecur</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span>
    <span class="o">{</span>

        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="n">right</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
            <span class="o">{</span>
                <span class="n">left</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="分治算法">分治算法</h3>

<p>分治算法可以求解的一些问题</p>

<ul>
  <li>二分搜索</li>
  <li>大整数乘法</li>
  <li>棋盘覆盖</li>
  <li>合并排序</li>
  <li>快速排序</li>
  <li>线性时间选择</li>
  <li>最接近点对问题</li>
  <li>循环赛日程表</li>
  <li>汉诺塔</li>
</ul>

<h4 id="分治算法设计模式">分治算法设计模式</h4>

<p><img src="/assets/img/sample/fenzhi.png" alt="分治" /></p>

<h4 id="分治算法实现汉诺塔">分治算法实现汉诺塔</h4>

<p>这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.fenzhi</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">hannoitower</span>
<span class="o">{</span>

<span class="c1">// 把n-1个盘子由A 移到 B；</span>
<span class="c1">// 把第n个盘子由 A移到 C；</span>
<span class="c1">// 把n-1个盘子由B 移到 C；</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span><span class="kt">char</span> <span class="n">a</span><span class="o">,</span><span class="kt">char</span> <span class="n">b</span><span class="o">,</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="c1">//只有一个盘直接从a移到c</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"第一个盘从"</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="s">"-&gt;"</span><span class="o">+</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//盘&gt;=2 总是看成两个盘</span>
            <span class="c1">//把最上面的盘全部移到b</span>
            <span class="n">play</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"第"</span><span class="o">+</span><span class="n">num</span><span class="o">+</span><span class="s">"个盘从"</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="s">"-&gt;"</span><span class="o">+</span><span class="n">c</span><span class="o">);</span>
            <span class="c1">//把b上面移到c</span>
            <span class="n">play</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name>晓</name></author><category term="数据结构与算法" /><category term="java" /><summary type="html"><![CDATA[常用算法]]></summary></entry><entry><title type="html">常用算法 一</title><link href="http://localhost:4000/posts/algorithm1/" rel="alternate" type="text/html" title="常用算法 一" /><published>2020-07-10T14:16:00+08:00</published><updated>2020-07-10T14:16:00+08:00</updated><id>http://localhost:4000/posts/algorithm1</id><content type="html" xml:base="http://localhost:4000/posts/algorithm1/"><![CDATA[<h2 id="常用算法">常用算法</h2>

<h3 id="非递归二分查找实现">非递归二分查找实现</h3>

<p>二分查找只适用于有序查找，需要先将数列进行排序</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.bsc</span><span class="o">;</span>

<span class="cm">/**
 * 非递归二分查找
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BsNoRecur</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearchNoRecur</span><span class="o">(</span><span class="kt">int</span> <span class="n">arr</span><span class="o">[],</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span>
    <span class="o">{</span>

        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]==</span><span class="n">target</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">mid</span><span class="o">]&gt;</span><span class="n">target</span><span class="o">)</span>
            <span class="o">{</span>
                <span class="n">right</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span>
            <span class="o">{</span>
                <span class="n">left</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="分治算法">分治算法</h3>

<p>分治算法可以求解的一些问题</p>

<ul>
  <li>二分搜索</li>
  <li>大整数乘法</li>
  <li>棋盘覆盖</li>
  <li>合并排序</li>
  <li>快速排序</li>
  <li>线性时间选择</li>
  <li>最接近点对问题</li>
  <li>循环赛日程表</li>
  <li>汉诺塔</li>
</ul>

<h4 id="分治算法设计模式">分治算法设计模式</h4>

<p><img src="/assets/img/sample/fenzhi.png" alt="分治" /></p>

<h4 id="分治算法实现汉诺塔">分治算法实现汉诺塔</h4>

<p>这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.fenzhi</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">hannoitower</span>
<span class="o">{</span>

<span class="c1">// 把n-1个盘子由A 移到 B；</span>
<span class="c1">// 把第n个盘子由 A移到 C；</span>
<span class="c1">// 把n-1个盘子由B 移到 C；</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span><span class="kt">char</span> <span class="n">a</span><span class="o">,</span><span class="kt">char</span> <span class="n">b</span><span class="o">,</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="c1">//只有一个盘直接从a移到c</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"第一个盘从"</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="s">"-&gt;"</span><span class="o">+</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//盘&gt;=2 总是看成两个盘</span>
            <span class="c1">//把最上面的盘全部移到b</span>
            <span class="n">play</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"第"</span><span class="o">+</span><span class="n">num</span><span class="o">+</span><span class="s">"个盘从"</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="s">"-&gt;"</span><span class="o">+</span><span class="n">c</span><span class="o">);</span>
            <span class="c1">//把b上面移到c</span>
            <span class="n">play</span><span class="o">(</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="动态规划算法">动态规划算法</h3>

<h4 id="核心思想">核心思想</h4>

<ul>
  <li>将大问题规划分为小问题进行解决，从而一步步虎丘最优解的处理算法</li>
  <li>动态规划算反与分治算法类似，其基本思想也是将带球解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解的到原问题的解</li>
  <li>与分治法不同的是，适合用于动态规划求解的问题，经分级得到子问题往往不是互相独立的。即下一个阶段的求解是建立在上一阶段的解的基础上进行进一步求解</li>
  <li>动态规划可以通过填表方式来逐步推进，得到最优解。</li>
</ul>

<h4 id="背包问题">背包问题</h4>]]></content><author><name>晓</name></author><category term="数据结构与算法" /><category term="java" /><summary type="html"><![CDATA[常用算法]]></summary></entry><entry><title type="html">图</title><link href="http://localhost:4000/posts/datastructure10/" rel="alternate" type="text/html" title="图" /><published>2020-07-02T14:16:00+08:00</published><updated>2020-07-02T14:16:00+08:00</updated><id>http://localhost:4000/posts/datastructure10</id><content type="html" xml:base="http://localhost:4000/posts/datastructure10/"><![CDATA[<p>1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。
这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。</p>

<p>图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中顶点的集合，E
是图 G 中边的集合。</p>

<p>1.线性表中数据元素 叫元素 。 树-结点 图-顶点 2.图是有穷非空集合，图结构中不允许没有顶点 3.线性表中，相邻数据元素之间具有线性关系</p>

<p>无向边 顶点之间的边没有方向，如果任意两个顶点之间的边都是无向边，则称该图为无向图。
若两顶点之间的边有方向，则称这条边为有向边，也称为弧。
无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图
在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</p>

<p><img src="/assets/img/sample/wuxiangtu.png" alt="图" />
<img src="/assets/img/sample/wuxiangtu1.png" alt="图" /></p>

<p>图的遍历
深度优先 （Depth First Search）
广度优先 (Braddth FS)</p>

<p>深度优先和广度优先，时间复杂度相同，不同之处仅仅在于对顶点访问的顺序不同。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.learn.graph</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">vertexList</span><span class="o">;</span> <span class="c1">//存储顶点集合</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">;</span> <span class="c1">//存储图对应的邻结矩阵</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">numOfEdges</span><span class="o">;</span> <span class="c1">//表示边的数目</span>
    <span class="c1">//定义给数组boolean[], 记录某个结点是否被访问</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//测试一把图是否创建ok</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>  <span class="c1">//结点的个数</span>
        <span class="c1">//String Vertexs[] = {"A", "B", "C", "D", "E"};</span>
        <span class="nc">String</span> <span class="nc">Vertexs</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">,</span> <span class="s">"6"</span><span class="o">,</span> <span class="s">"7"</span><span class="o">,</span> <span class="s">"8"</span><span class="o">};</span>

        <span class="c1">//创建图对象</span>
        <span class="nc">Graph</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Graph</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="c1">//循环的添加顶点</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="nl">vertex:</span> <span class="nc">Vertexs</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">insertVertex</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">//添加边</span>
        <span class="c1">//A-B A-C B-C B-D B-E</span>
<span class="c1">//		graph.insertEdge(0, 1, 1); // A-B</span>
<span class="c1">//		graph.insertEdge(0, 2, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 2, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 3, 1); //</span>
<span class="c1">//		graph.insertEdge(1, 4, 1); //</span>

        <span class="c1">//更新边的关系</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">insertEdge</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>



        <span class="c1">//显示一把邻结矩阵</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">showGraph</span><span class="o">();</span>

        <span class="c1">//测试一把，我们的dfs遍历是否ok</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"深度遍历"</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">dfs</span><span class="o">();</span> <span class="c1">// A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7]</span>
<span class="c1">//		System.out.println();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"广度优先!"</span><span class="o">);</span>
        <span class="n">graph</span><span class="o">.</span><span class="na">bfs</span><span class="o">();</span> <span class="c1">// A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8]</span>

    <span class="o">}</span>

    <span class="c1">//构造器</span>
    <span class="kd">public</span> <span class="nf">Graph</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//初始化矩阵和vertexList</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">vertexList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">numOfEdges</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="c1">//得到第一个邻接结点的下标 w</span>
    <span class="cm">/**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getFirstNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//根据前一个邻接结点的下标来获取下一个邻接结点</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNextNeighbor</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//深度优先遍历算法</span>
    <span class="c1">//i 第一次就是 0</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//首先我们访问该结点,输出</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"-&gt;"</span><span class="o">);</span>
        <span class="c1">//将结点设置为已经访问</span>
        <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//查找结点i的第一个邻接结点w</span>
        <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span><span class="c1">//说明有</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">//如果w结点已经被访问过</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">//对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="c1">//遍历所有的结点，进行dfs[回溯]</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getNumOfVertex</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//对一个结点进行广度优先遍历的方法</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">isVisited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">;</span> <span class="c1">// 表示队列的头结点对应下标</span>
        <span class="kt">int</span> <span class="n">w</span> <span class="o">;</span> <span class="c1">// 邻接结点w</span>
        <span class="c1">//队列，记录结点访问的顺序</span>
        <span class="nc">LinkedList</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">();</span>
        <span class="c1">//访问结点，输出结点信息</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"=&gt;"</span><span class="o">);</span>
        <span class="c1">//标记为已访问</span>
        <span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">//将结点加入队列</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

        <span class="k">while</span><span class="o">(</span> <span class="o">!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">//取出队列的头结点下标</span>
            <span class="n">u</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span><span class="n">queue</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
            <span class="c1">//得到第一个邻接结点的下标 w</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">getFirstNeighbor</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
            <span class="k">while</span><span class="o">(</span><span class="n">w</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span><span class="c1">//找到</span>
                <span class="c1">//是否访问过</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getValueByIndex</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">+</span> <span class="s">"=&gt;"</span><span class="o">);</span>
                    <span class="c1">//标记已经访问</span>
                    <span class="n">isVisited</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="c1">//入队</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">//以u为前驱点，找w后面的下一个邻结点</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">getNextNeighbor</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span> <span class="c1">//体现出我们的广度优先</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">//遍历所有的结点，都进行广度优先搜索</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">isVisited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">getNumOfVertex</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isVisited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">bfs</span><span class="o">(</span><span class="n">isVisited</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//图中常用的方法</span>
    <span class="c1">//返回结点的个数</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumOfVertex</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">//显示图对应的矩阵</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">showGraph</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">link</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">link</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//得到边的数目</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumOfEdges</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">numOfEdges</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//返回结点i(下标)对应的数据 0-&gt;"A" 1-&gt;"B" 2-&gt;"C"</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getValueByIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">vertexList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//返回v1和v2的权值</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">v2</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="c1">//插入结点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertVertex</span><span class="o">(</span><span class="nc">String</span> <span class="n">vertex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vertexList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//添加边</span>
    <span class="cm">/**
     *
     * @param v1 表示点的下标即使第几个顶点  "A"-"B" "A"-&gt;0 "B"-&gt;1
     * @param v2 第二个顶点对应的下标
     * @param weight 表示
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">edges</span><span class="o">[</span><span class="n">v1</span><span class="o">][</span><span class="n">v2</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
        <span class="n">edges</span><span class="o">[</span><span class="n">v2</span><span class="o">][</span><span class="n">v1</span><span class="o">]</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
        <span class="n">numOfEdges</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name>晓</name></author><category term="数据结构与算法" /><category term="tree" /><category term="java" /><summary type="html"><![CDATA[1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。]]></summary></entry></feed>